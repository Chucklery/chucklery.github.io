<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试题 | Fuhaoyu's Blog</title><meta name="keywords" content="Front 面试题"><meta name="author" content="Fuhaoyu"><meta name="copyright" content="Fuhaoyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CPU 执行原理 以及冯诺依曼体系结构  说一下 LHS RHS 是什么  100T 文件如何遍历里面的信息?  介绍一下dll 文件  HTML 的字符实体是什么  js底层数据结构如何存储在V8里面  H5新特性  如果提到localstorage 就追问 localstorage API 以及 localStorage 实现原理 以及 localStorage 存在哪儿 以及localSt">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://chucklery.github.io/2024/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Fuhaoyu&#39;s Blog">
<meta property="og:description" content="CPU 执行原理 以及冯诺依曼体系结构  说一下 LHS RHS 是什么  100T 文件如何遍历里面的信息?  介绍一下dll 文件  HTML 的字符实体是什么  js底层数据结构如何存储在V8里面  H5新特性  如果提到localstorage 就追问 localstorage API 以及 localStorage 实现原理 以及 localStorage 存在哪儿 以及localSt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://chucklery.github.io/img/eye.png">
<meta property="article:published_time" content="2024-09-20T08:48:26.000Z">
<meta property="article:modified_time" content="2024-09-23T08:26:24.554Z">
<meta property="article:author" content="Fuhaoyu">
<meta property="article:tag" content="Front 面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://chucklery.github.io/img/eye.png"><link rel="shortcut icon" href="/img/Head.jpg"><link rel="canonical" href="http://chucklery.github.io/2024/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?62e822c7fda718142f4518e3531ea4df"";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: Fuhaoyu","link":"链接: ","source":"来源: Fuhaoyu's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-23 16:26:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/Head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-university"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-retweet"></i><span> 时间帧</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-chevron-circle-down"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-paper-plane"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/eye.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Fuhaoyu's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-university"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-retweet"></i><span> 时间帧</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-chevron-circle-down"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-paper-plane"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heartbeat"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-20T08:48:26.000Z" title="发表于 2024-09-20 16:48:26">2024-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-23T08:26:24.554Z" title="更新于 2024-09-23 16:26:24">2024-09-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ol>
<li><p>CPU 执行原理 以及冯诺依曼体系结构</p>
</li>
<li><p>说一下 LHS RHS 是什么</p>
</li>
<li><p>100T 文件如何遍历里面的信息?</p>
</li>
<li><p>介绍一下dll 文件</p>
</li>
<li><p>HTML 的字符实体是什么</p>
</li>
<li><p>js底层数据结构如何存储在V8里面</p>
</li>
<li><p>H5新特性</p>
</li>
<li><p>如果提到localstorage 就追问 localstorage API 以及 localStorage 实现原理 以及 localStorage 存在哪儿 以及localStorage 跨域</p>
</li>
<li><p>如果提到PWA技术 就追问 PWA优点 继续追问 Service Workers 继续追问 PWA和hybrid的不同</p>
</li>
<li><p>如果提到canvas 就追问 canvas 常用API</p>
</li>
<li><p>如果提到webSocket 就追问 webSocket 的用法 以及手动实现ws协议 继续追问SSE技术 和 ws的区别</p>
</li>
<li><p>如果提到webWorker 就追问 webWorker 用法 以及实现原理</p>
</li>
<li><p>浏览器如何跨tab页通讯？</p>
</li>
<li><p>如何区分强网弱网</p>
</li>
<li><p>什么是灰度</p>
</li>
<li><p>async defer</p>
</li>
<li><p>SEO</p>
</li>
<li><p>BFC</p>
</li>
<li><p>回流与重绘 以及优化方案</p>
</li>
<li><p>webComponents 以及 微前端 以及 emp 模块联邦</p>
</li>
<li><p>Css盒模型 和 怪异盒模型区别 以及统一策略</p>
</li>
<li><p>css 伪类</p>
</li>
<li><p>为什么哔哩哔哩用vmin 不用 vh</p>
</li>
<li><p>css变量</p>
</li>
<li><p>css flex grid</p>
</li>
<li><p>Css 动画 关键帧等</p>
</li>
<li><p>bem架构</p>
</li>
<li><p>如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 答：多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</p>
</li>
<li><p>less scss 解决了什么问题</p>
</li>
<li><p>postCss 是干嘛的 是否用过 是否写过插件</p>
</li>
<li><p>是否用过tailwindCss 是否用过unoCss</p>
</li>
<li><p>typeOf n  l 是什么 原因是什么</p>
</li>
<li><p>比较两个对象是否相等</p>
</li>
<li><p>判断是不是数组</p>
</li>
<li><p>说说常用的es6</p>
</li>
<li><p>proxy Reflect 为什么要配合 proxy劫持 函数 劫持for in</p>
</li>
<li><p>迭代器 生成器 for of 以及 Iterator 以及数组解构原理 和对象解构原理（深入V8引擎）</p>
</li>
<li><p>Class 用法 super原理 继承 如何定义私有属性</p>
</li>
<li><p>AMD CMD UMD CJS ESM IIFE 的区别</p>
</li>
<li><p>Promise 静态方法 以及 all 实现原理 有限状态机</p>
</li>
<li><p>map set weakMap weakSet</p>
</li>
<li><p>微任务 宏任务 同步 异步 async await</p>
</li>
<li><p>装饰器 以及 装饰器解决了什么问题</p>
</li>
<li><p>ArrayBuffer 如何使用 以及跟webGl 的关系</p>
</li>
<li><p>讲一下 GLSL Shader 实现亮度(Brightness)、对比度(Contrast) 和边缘检测(Edge Detection) 是如何实现的回答的时候忘记了对比度的算法实现没答上来，讲了下明度 Luminance 的调节；亮度Brightness是RGB+亮度系数；边缘检测和图像锐化是使用 Convolution Kernel 卷积核加深中心像素与周围像素的色彩差值梯度，使边缘更加突出</p>
</li>
<li><p>计算机图形绘制原理</p>
</li>
<li><p>WebAssembly 工作原理 如何编译成wasm</p>
</li>
<li><p>webRTC 架构 如何 实现推流 拉流</p>
</li>
<li><p>垃圾回收 内存泄漏 堆栈</p>
</li>
<li><p>深拷贝 防抖 节流</p>
</li>
<li><p>实现深拷贝的几种方法 追问 对象群嵌套15层 我想用14层的一个属性 最优解决方案 引出 Immutable js 追问 Immutable js 实现原理 字典 位分区 及 树压缩算法</p>
</li>
<li><p>什么是纯函数 什么是副作用函数</p>
</li>
<li><p>浏览器输入一个url 发生了什么 DNS解析顺序 追问OSI 七层网络模型 三次握手 http https 区别 http1 2 3 区别 强缓存 协商缓存</p>
</li>
<li><p>TCP 跟 UDP 的区别</p>
</li>
<li><p>TCP 的 超时重传协议 滑动窗口思想</p>
</li>
<li><p>Ajax fetch navigator.sendBeacon 三个的区别</p>
</li>
<li><p>nodejs 是否用过</p>
</li>
<li><p>nodejs-napi addon</p>
</li>
<li><p>是否用过一些库 如 express koa nest 追问用的什么数据库 以及高速缓存 如 redis ，用的什么ORM框架，如果熟悉express 追问 中间件原理，熟悉nest 追问 ioc控制反转 DI 依赖注入 设计模式 以及MVC 架构 和MVVM 区别 继续追问nest rxjs 库用法 以及原理 继续追问nest 微服务 gRPC MQ 以及网关 。</p>
</li>
<li><p>聊聊数据库 mysql 底层数据结构 为什么使用B+ 树，继续追问 mysql事务以及四大特性 追问悲观锁和乐观锁</p>
</li>
<li><p>数据库的引擎？</p>
</li>
<li><p>聊聊redis redis是单线程还是多线程 以及底层原理</p>
</li>
<li><p>聊聊nodejs 的 vm虚拟机 以及PAI 以及 底层libuv openSSL</p>
</li>
<li><p>聊聊nodejs 子线程 进程守卫怎么做</p>
</li>
<li><p>聊聊 断点续传怎么做（前后端）</p>
</li>
<li><p>Npm 是什么 package-lock.json 是做什么的 npm 缓存原理</p>
</li>
<li><p>pnpm 实现原理 以及 monorepo 架构</p>
</li>
<li><p>如何发布 npm 包 有没有发过 自己的 npm包 周下载量多少</p>
</li>
<li><p>webpack vite rollup esbuild swc g  p</p>
</li>
<li><p>Webpack 脱口而出的配置 webpack 分包 webpack 打包优化 webpack打包原理 以及 HMR 原理</p>
</li>
<li><p>Vite原理 中间件原理 是否写过vite插件</p>
</li>
<li><p>rollup 和 webpack的区别</p>
</li>
<li><p>esBuild 常用命令 以及 为什么这么快</p>
</li>
<li><p>Vue2 3 区别</p>
</li>
<li><p>Diff算法 追问 最长递增子序列算法 以及 二分查找 和 贪心算法</p>
</li>
<li><p>响应式原理 追问 为什么使用位运算</p>
</li>
<li><p>Vue源码调度机制 以及nextTick执行机制</p>
</li>
<li><p>Vue3 新增2个内置组件 介绍</p>
</li>
<li><p>Vue3 keep-alive LRU 算法以及原理介绍</p>
</li>
<li><p>Vue-router 原理 hash 和 history 以及 对应微前端 以及monorepo 架构</p>
</li>
<li><p>Pinia vuex 设计模式 以及实现原理 为什么刷新数据丢失 以及解决方案</p>
</li>
<li><p>AOT 和 JIT 的区别</p>
</li>
<li><p>动态扩容 动态缩容 横向扩容 怎么做</p>
</li>
<li><p>nginx 四层LB负载均衡 nginx七层LSB 负载均衡怎么做 nginx多机房异地容灾怎么做</p>
</li>
<li><p>两地三中心 怎么做？</p>
</li>
<li><p>nginx源码中的unix域是怎么做的 做什么的</p>
</li>
<li><p>nginx lua插件怎么写</p>
</li>
<li><p>网关怎么做 网关熔断怎么做 网关分流怎么做 网关加密怎么做</p>
</li>
<li><p>FPS 帧率 requestIdleCallback performance</p>
</li>
</ol>
<h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ol>
<li>什么是服务熔断？什么是服务降级？</li>
<li>Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</li>
<li>SpringBoot和SpringCloud的区别？</li>
<li>SpringBoot和SpringCloud的区别？</li>
<li>什么是 feigin ？它的优点是什么？</li>
<li>Ribbon和Feign的区别？</li>
</ol>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><ol>
<li>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</li>
<li>运行Spring Boot有哪几种方式？</li>
<li>如何理解 Spring Boot 中的 Starters？</li>
<li>如何在Spring Boot启动的时候运行一些特定的代码？</li>
<li>Spring Boot 需要独立的容器运行吗？</li>
<li>Spring Boot中的监视器是什么？</li>
<li>如何使用Spring Boot实现异常处理？</li>
<li>你如何理解 Spring Boot 中的 Starters？</li>
<li>springboot常用的starter有哪些</li>
<li>SpringBoot 实现热部署有哪几种方式？</li>
<li>如何理解 Spring Boot 配置加载顺序？</li>
<li>Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</li>
<li>如何集成 Spring Boot 和 ActiveMQ？</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ol>
<li>Redis篇</li>
<li>为什么要用缓存</li>
<li>说说 Redis 的线程模型</li>
<li>Redis 持久化方式有哪些？以及有什么区别？</li>
<li>怎么使用 Redis 实现消息队列？</li>
<li>说说你对Redis事务的理解</li>
<li>熟悉哪些 Redis 集群模式？</li>
<li>Redis 常见性能问题和解决方案有哪些？</li>
<li>Redis 报内存不足怎么处理？</li>
<li>说说Redis持久化机制</li>
<li>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问</li>
<li>redis的数据类型，以及每种数据类型的使用场景</li>
<li>Redis 为什么是单线程的</li>
<li>Redis 常见性能问题和解决方案？</li>
<li>了解Redis的事务吗？</li>
<li>Redis 的数据类型及使用场景</li>
</ol>
<h1 id="———————————————–"><a href="#———————————————–" class="headerlink" title="———————————————–"></a>———————————————–</h1><p> 网络协议 </p>
<ol>
<li> Http有哪些版本？你正在使用哪个版本？如何查看？ </li>
</ol>
<p>http版本分布</p>
<ol>
<li><p>0.9</p>
</li>
<li><p>1.0</p>
</li>
<li><p>1.1</p>
</li>
<li><p>2.0</p>
</li>
<li><p>3.0</p>
<p>有两种查看http版本：</p>
<p>2.0的表现</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.001.png"></p>
<p>1.1的表现</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.002.png"></p>
<p>window.chrome.loadTimes()</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.003.png"></p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.004.png"></p>
<pre><code> name=&quot;heading_7&quot;&gt; 2.  可以简述一下http版本的发展过程吗？ 
</code></pre>
<p>HTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。HTTP 0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。</p>
<p>HTTP1.0是HTTP协议的第二个版本。</p>
</li>
</ol>
<ul>
<li><p> 增加了请求方式POST </p>
</li>
<li><p>新增请求头、http状态码等</p>
</li>
<li><p>新增Cookie</p>
<p>HTTP1.1</p>
</li>
<li><p>新增keep-alive长连接</p>
</li>
<li><p>新增pipeline管道</p>
</li>
<li><p>增加了 PUT、DELETE、OPTIONS、PATCH 等新的方法</p>
<p>HTTP2.0</p>
</li>
<li><p>头部支持二进制协议，支持头部压缩</p>
</li>
<li><p>新增多路复用</p>
<p>HTTP3.0</p>
<p>http协议的历史性革命性大改版，将底层TCP协议改为UDP，彻底解决队头阻塞问题。</p>
<p>缺点： 兼容性还不行，不能大规模使用。</p>
</li>
</ul>
<ol start="3">
<li> HTTP1.1有哪些特点 </li>
</ol>
<p>   HTTP1.1 默认使用 Connection:keep-alive（长连接），避免了连接建立和释放的开销。</p>
<p>  支持pipeline管道传输，可以不必等待请求响应就发起下一个请求，但是响应结果必须保持发送出去的顺序。有一个卡住就会把后面都卡住，这个是硬伤。</p>
<ol>
<li><p>长连接：引入了 TCP 连接复用，即一个 TCP 默认不关闭，可以被多个请求复用</p>
</li>
<li><p>并发连接（谷歌是6个）：对一个域名的请求允许分配多个长连接（缓解了长连接中的「队头阻塞」问题）</p>
</li>
<li><p>引入管道机制（pipelining），一个 TCP 连接，可以同时发送多个请求。（响应的顺序必须和请求的顺序一致，因此不常用）</p>
</li>
<li><p>增加了 PUT、DELETE、OPTIONS、PATCH 等新的方法</p>
</li>
<li><p>新增了一些缓存的字段（If-Modified-Since, If-None-Match）</p>
</li>
<li><p>请求头中引入了 range 字段，支持断点续传</p>
</li>
<li><p>允许响应数据分块（chunked），利于传输大文件</p>
</li>
<li><p>强制要求 Host 头，让互联网主机托管称为可能</p>
<p><a name="heading_9">  4.  HTTP2.0有哪些特点 </p>
</li>
<li><p>「二进制协议：」 HTTP/1.1版本的头部信息是文本，数据部分可以是文本也可以是二进制。HTTP/2版本的头部和数据部分都是二进制，且统称为‘帧’</p>
</li>
<li><p>「多路复用：」 废弃了 HTTP/1.1 中的管道，同一个TCP连接里面，客户端和服务器可以同时发送多个请求和多个响应，并且不用按照顺序来。由于服务器不用按顺序来处理响应，所以避免了“队头堵塞”的问题。</p>
</li>
<li><p>「头部信息压缩：」 使用专用算法压缩头部，减少数据传输量，主要是通过服务端和客户端同时维护一张头部信息表，所有的头部信息在表里面都会有对应的记录，并且会有一个索引号，这样后面只需要发送索引号即可</p>
</li>
<li><p>「服务端主动推送：」 允许服务器主动向客户推送数据</p>
</li>
<li><p>「数据流：」 服务器以流stream的形式向客户端返回内容。</p>
<p><a name="heading_10">  5.  什么是长连接？Keep-alive </p>
<p>tcp的每次连接建立都需要三次握手，例如：发，收，发，收。</p>
<p><code> </code>如果开启长连接就可以避免，每次发收、发收都要进行三次握手。</p>
<p>只需三次握手一次就可以进行，多次收发、收发。</p>
<p><a name="heading_11">  6.  pipeline和长连接的区别？和多路复用的区别呢？ </p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.005.png"></p>
<p>pipeline的基础是长连接，它一定要建立在长连接之上。</p>
<p>长连接-非pipeline， 发一条，收一条，发一条，收一条，没收到就不能发下一条。</p>
<p>长连接-pipeline，发1，发2，发3， 收1，收2，收3。但是收必须发的顺序，如果有一个收卡住，后面全卡住。</p>
<p>多路复用： 它是基于http的二进制”分帧”。假如我们发1需要收到的数据收1是这样[1-1，1-2，1-3]。如果没用多路复用，那请求必须收到完整的数据[1-1, 1-2,1-3]才算结束。 有了多路复用技术之后，我们收到的数据实际上不需要包装顺序和完整，例如1-1, 2-1, 3-1, 1-2, 1-3, 最后http会自己把数据组装成[1-1, 1-2, 1-3]交给发1。这样就解决了http层面的队头阻塞问题。收到的数据不需要和发出去的顺序一致。</p>
<p>多路复用示意图：</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.006.png"></p>
<p><a name="heading_12">  7.  HTTP3.0有什么特点？ </p>
<p>我们都知道http是基于TCP协议实现的。</p>
<p>TCP 的主要作用是以正确的顺序将整个字节流从一个端点传输到另一个端点，但是当流中的某些数据包丢失时，TCP 需要重新发送这些丢失的数据包，等到丢失的数据包到达对应端点时才能够被 HTTP 处理，这被称为 TCP 队头阻塞问题。</p>
<p>多路复用解决的是HTTP层面的对头阻塞问题，而不是TCP层面的。</p>
<p>HTTP3.0就是主要解决这个问题的。</p>
<p>基于这个原因， Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上 </p>
<p>首先 QUIC 的第一个特征就是快，为什么说它快，它到底快在哪呢？</p>
<p>HTTP 协议在传输层是使用了 TCP 进行报文传输，建立连接需要进行3次握手。</p>
<p>QUIC 的握手连接更快，因为它使用了 UDP 作为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE&spm=1001.2101.3001.7020">传输层协议</a>，这样能够减少三次握手的时间延迟。</p>
</li>
</ol>
<ul>
<li><p>使用 UDP 协议，不需要三次连接进行握手，而且也会缩短 TLS （HTTPS）建立连接的时间。</p>
</li>
<li><p>彻底解决了队头阻塞问题。</p>
</li>
<li><p>实现动态可插拔，在应用层实现了拥塞控制算法，可以随时切换。</p>
</li>
<li><p>报文头和报文体分别进行认证和加密处理，保障安全性。</p>
</li>
<li><p>连接能够平滑迁移。</p>
<p>连接平滑迁移指的是，你的手机或者移动设备在 4G 信号下和 WiFi 等网络情况下切换，不会断线重连，用户甚至无任何感知，能够直接实现平滑的信号切换。</p>
<p><a name="heading_13">  8.  网络是怎么分层的？ </p>
<p>1）物理层<br><code> </code>该层负责比特流在节点间的传输，即负责物理传输。通俗来讲就是把计算机连接起来的物理手段。</p>
<p>代表作用：传输 0 1 0 1信号</p>
<p>代表设备： 网线、光纤</p>
</li>
</ul>
<p>  <code> </code>2）数据链路层<br>  <code> </code>该层控制网络层与物理层之间的通信，其主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。</p>
<p>  帧就是对0 1 数据的封装。</p>
<p>  一帧是64-1518字节。</p>
<p>  代表作用： Mac地址确认、Arp广播</p>
<p>  代表设备： 交换机</p>
<p>  <code> </code>3）网络层<br>  <code> </code>该层决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中的节点 A 到另一个网络中节点 B 的最佳路径。</p>
<p>  代表作用：分配IP地址</p>
<p>  代表设备： 家用路由器</p>
<p>  <code> </code>4）传输层<br>  <code> </code>该层为两台主机上的应用程序提供端到端的通信。相比之下，网络层的功能是建立主机到主机的通<br>  <code> </code>信。</p>
<p>  代表作用：连接端到端、例如TCP、UDP</p>
<p>  代表设备： 操作系统内核</p>
<p>  5）应用层<br>  应用程序收到传输层的数据后，接下来就要进行解读。解读必须事先规定好格式，而应用层就是规定应用程序的数据格式的。它的主要协议有HTTP、FTP、Telnet、SMTP、POP3等。</p>
<p>  <a name="heading_14">  9.  Tcp和Udp的区别 </p>
<ul>
<li><p>TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务，UDP 是无连接的，即发送数据之前不需要建立连接，UDP 尽最大努力交付，即不保证可靠交付。</p>
</li>
<li><p>UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性有较高的通信或广播通信。</p>
</li>
<li><p>UDP应用场景： 直播，游戏</p>
</li>
<li><p>TCP应用场景： 网页</p>
</li>
<li><p>每一条 TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一和多对多的交互通信。</p>
</li>
<li><p>UDP 分组首部开销小，TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。</p>
</li>
<li><p>TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位。</p>
</li>
<li><p>UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP （专业的网管，比如服务器、路由器、交换机统一管理、排查错误等等）等。</p>
<p><a name="heading_15">  10.  Tcp的三次握手 </p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.007.png"></p>
<p>「第一次握手：」 客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>「第二次握手：」 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>「第三次握手：」 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><a name="heading_16">  11.  tcp的四次挥手，客户端断开的时候为什么要两个MSL？ </p>
<p>回答要点：</p>
</li>
</ul>
<ol>
<li><p>服务器为什么要返回两次，比建立连接多一次？</p>
</li>
<li><p>断开方为什么要等待2MSL才能真正断开？</p>
<p>通信所要解决的首要问题就是，保持通信双方的信息对称，使通信双方处于同步状态。</p>
<p>先来一个例子：</p>
<p>罗密欧大学期间写信给中学同学朱丽叶，信的内容如下：</p>
<p>小叶子，我喜欢你！</p>
<p>这封信发出之后，罗密欧无法知道朱丽叶能否收到，只有收到小叶子的回信，才能知道自己的信已经到达对方。</p>
<p>三天之后，小叶子回信了，信的内容如下：</p>
<p>小欧，来信已阅，我也喜欢你…</p>
<p>此时，小叶子眼中双方的状态是：互相爱慕！</p>
<p>如果小欧收到回信，小欧眼中双方的状态也是：互相爱慕！</p>
<p>如果小欧没有收到回信，小欧眼中双方的状态是：单相思！</p>
<p>小叶子为了杜绝小欧模棱两可的状态，使他与自己达成“互相爱慕”的共识，需要做以下工作：</p>
<p>1）先耐心地等小欧的第三封信</p>
<p>2）如果若干天没有收到回信，需要把自己的第二封信再次发出</p>
<p>如果收到了小欧的回信，那么双方的状态终于同步了：“互相爱慕”！</p>
<p>即使2）发生了，N天之后也可以达成同步状态。</p>
<p>之后，双方可以甜言蜜语地谈恋爱了。</p>
<p>TCP四次挥手也遵循相似的套路。</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.007.png"></p>
<p>主动断开的一侧为A，被动断开的一侧为B。</p>
<p>第一个消息：A发FIN</p>
<p>第二个消息：B回复ACK</p>
<p>第三个消息：B发出FIN</p>
<p>此时此刻：B单方面认为自己与A达成了共识，即双方都同意关闭连接。</p>
<p>此时，B能释放这个TCP连接占用的内存资源吗？不能，B一定要确保A收到自己的ACK、FIN。</p>
<p>所以B需要静静地等待A的第四个消息的到来：</p>
<p>第四个消息：A发出ACK，用于确认收到B的FIN</p>
<p>当B接收到此消息，即认为双方达成了同步：双方都知道连接可以释放了，此时B可以安全地释放此TCP连接所占用的内存资源、端口号。</p>
<p>所以被动关闭的B无需任何wait time，直接释放资源。</p>
<p>但，A（客户端）并不知道B（服务器）是否接到自己的ACK，A是这么想的：</p>
<p>1）如果B没有收到自己的ACK，会超时重传FiN</p>
<p>那么A再次接到重传的FIN，会再次发送ACK</p>
<p>2）如果B收到自己的ACK，也不会再发任何消息，包括ACK</p>
<p>无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：</p>
<p>去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。</p>
<p>这恰恰就是2MSL( Maximum Segment Life)。</p>
<p>等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。</p>
<p>1MSL实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>小故事-四次挥手的过程：</p>
<p>客户端是A， 服务器是B，它们是情侣</p>
<p>A=&gt;B说： 我们分手吧 （第一次挥手）</p>
<p>B=&gt; A: 好，我知道了，等我想一想。</p>
<p>B=&gt; A: 好，我同意，分手吧。</p>
<p>A =&gt;B: 行，滚吧。</p>
<p>真实环境的四次挥手：</p>
</li>
<li><p>浏览器给服务器说： 断开吧</p>
</li>
<li><p>服务器说： 好，我知道了，我确认一下有没用数据没传完</p>
</li>
<li><p>服务器又说： 我这边传完了，可以断开了</p>
</li>
<li><p>浏览器： 好的，断开了</p>
<p><a name="heading_17">  12.  常见http状态码有哪些 </p>
<p><code>      </code>1xx：表示正在处理你的请求</p>
<p><code>      </code>2xx：表示你的请求成功了，经典状态码200表示成功请求和响应</p>
<p><code>      </code>3xx：表示浏览器需要做一些其他处理才能继续处理请求，</p>
<p><code>                 </code>302重定向</p>
<p><code>                 </code>304缓存</p>
<p><code>    </code>4xx:表示客户端发生一些错误</p>
</li>
</ol>
<p><code>    </code>401： 没登陆</p>
<p><code>    </code>403：已经登录，但是这个模块你没有权限</p>
<p><code>         </code>404服务器上没有请求的资源等等</p>
<p><code>    </code>5xx：表示后端发生错误</p>
<p><a name="heading_18">  13.  TCP中的滑动窗口有什么作用 </p>
<p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区（内存占用）可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。</p>
<p>客户端和服务器达成一致，我到底要发送多大的数据包过去给对方。</p>
<p>TCP也维持了一个滑动窗口，它解决是个端到端的问题，并且动态变化。</p>
<p><a name="heading_19">  14.  TCP的拥塞控制有什么作用 </p>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个  拥塞窗口(cwnd)  的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。</p>
<p><a name="heading_20">  15.  滑动窗口和拥塞控制的区别？ </p>
<p>滑动窗口解决我跟你自己本身的问题。</p>
<p>拥塞控制解决，我去你那里的路况拥堵问题。</p>
<p>滑动窗口：</p>
<p>你邀请我，去你家玩耍。</p>
<p>我家里人多，准了8台车。</p>
<p>你家的院子只能停4台车。</p>
<p>你能否分两批来玩？</p>
<p>这个过程就叫滑动窗口。</p>
<p>拥塞窗口：</p>
<p>你邀请我，去你家玩耍。</p>
<p>我家里人多，准了8台车。</p>
<p>你家的院子也能停8台车。</p>
<p>但是今天周末，超级堵车。</p>
<p>我的车只能一台一台出发，比如每隔五分钟出发一辆。</p>
<p>我同时出发8台车呢？</p>
<p>会把路堵死，更慢。</p>
<p>发送方让自己的发送窗口取拥塞窗口和滑动窗口中较小的一个。</p>
<p><a name="heading_21">  16.  说一下https的加密过程 </p>
<p>对称加密： 这把钥匙能加密也能解密</p>
<p>非对称加密： 有两把钥匙，一把只加密（公钥），一把只解密（私钥）</p>
<p>1）客户端发起一个http请求，告诉服务器自己支持哪些hash算法。</p>
<p>2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。</p>
<p>3）验证证书的合法性</p>
<p>客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。</p>
<p>4）生成随机密码（RSA签名）</p>
<p>如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。</p>
<p>服务端和浏览器之间，使用非对称加密来沟通一个“随机字符串”，双方都知道这个”随机字符”。后续的通信过程就使用这个随机的字符串作为对称加密的密钥，来对双方沟通的内容来进行加密和解密。</p>
<p>5）生成对称加密算法</p>
<p>验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。</p>
<p><a name="heading_22">  17.  https是绝对安全的吗？ </p>
<p>不是绝对安全的。</p>
<p>有一种攻击手段叫做“中间人攻击”。</p>
<p>简单一点讲，这个中间人对浏览器冒充服务器，对服务器冒充浏览器。这样就可以拿到你们通信数据了，并且可以篡改。</p>
<p>如何防范：</p>
<ol>
<li><p>不要轻易信任证书，不知名的小网站不要随意访问</p>
</li>
<li><p>浏览器给安全提示的是，那就是有风险的，要谨慎</p>
</li>
<li><p>不要随意连接公共wifi</p>
<p><a name="heading_23">  18.  请谈一下浏览器的强缓存和协商缓存 </p>
<p><a name="heading_24">   强缓存 </p>
<p>强缓存是通过​​Expires​​​与​​Cache-Control​​来控制缓存在本地的有效期。</p>
<p>Expires</p>
<table>
<thead>
<tr>
<th align="left">Expires​​​是​​HTTP 1.0​​​提出的一个表示资源过期时间的​​Header​​​，它描述的是一个绝对时间，由服务器返回。​​Expires​​​受限于本地时间，如果修改了本地时间，可能会造成缓存失效.对于资源的请求，如果在​​Expires​​之内，则浏览器会直接读取缓存，不再请求服务器。</th>
</tr>
</thead>
</table>
<p>Expires: Sun, 14 Jun 2020 02:50:57 GMT</p>
<p>Cache-Control</p>
<table>
<thead>
<tr>
<th align="left">Cache-Control​​​出现于​​HTTP 1.1​​​，优先级高于​​Expires​​，表示的是相对时间，请求头和响应头都支持这个属性，通过它提供的不同的值来定义缓存策略。</th>
</tr>
</thead>
</table>
<p>Cache-Control: max-age=300（s）</p>
<p>Cache-Control: no-store: 缓存中不得存储任何关于客户端请求和服务端响应的内容，每次由客户端发起的请求都会下载完整的响应内容。</p>
<p>Cache-Control: no-cache: 缓存中会存储服务端响应的内容，只是在与服务端进行新鲜度再验证之前，该缓存不能够提供给浏览器使用。简单来说，就是浏览器会将服务端响应的资源进行缓存，但是在每次请求时，缓存都要向服务端评估缓存响应的有效性，协商缓存是否可用，根据响应是​​304​​​还是​​200​​判断是使用本地缓存资源还是使用服务器响应的资源。</p>
<p>Cache-Control: public || private:public​​​表示该响应可以被任何中间人比如中间代理、​​CDN​​​等缓存。默认响应为​​private​​​，​​private​​表示该响应是专用的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p>
<p>Cache-Control: max-age=31536000: 响应为最大的过期时间，其指令是​​max-age=<seconds>​​​，表示资源能够被缓存即保持新鲜的最大时间，​​max-age​​是距离请求发起的时间的秒数。</p>
<p>Cache-Control: must-revalidate: 当使用了​​must-revalidate​​​指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。在正常情况下是没有必要使用这个指令的，因为在强缓存过期的情况下会进行协商缓存，但是​​HTTP​​​规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候，还比如有配置一些特殊指令​​stale-while-revalidate​​​、​​stale-if-error​​​等的时候，​​must-revalidate​​指令就是让缓存在过期后的任何情况下都必须重新验证。</p>
<p><a name="heading_25">   协商缓存 </p>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的​​HTTP​​​状态为​​304 (Not Modified)​​​，该请求不携带实体数据，若未命中，则返回​​200​​​并携带资源实体数据。协商缓存是利用的是​​Last-Modified，If-Modified-Since​​​和​​ETag、If-None-Match​​​这两对​​Header​​来管理的。</p>
<p>Last-Modified If-Modified-Since</p>
<p>Last-Modified，If-Modified-Since​​​是​​HTTP 1.0​​​引入的，​​Last-Modified​​​表示本地文件最后修改日期，浏览器会在请求头加上​​If-Modified-Since​​​即上次响应的​​Last-Modified​​​的值，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，但是如果在本地打开缓存文件，就会造成​​Last-Modified​​​被修改，所以在​​HTTP 1.1​​​出现了​​ETag​​。</p>
<p>ETag If-None-Match</p>
<p>Etag​​​就像一个指纹，资源变化都会导致​​ETag​​​变化，跟最后修改时间没有关系，​​ETag​​​可以保证每一个资源是唯一的，​​If-None-Match​​​的请求头字段会将上次返回的​​Etag​​​发送给服务器，询问该资源的​​Etag​​​是否有更新，有变动就会发送新的资源回来。​​ETag​​​的优先级比​​Last-Modified​​​更高，具体使用​​ETag​​主要出于下面几种情况考虑：</p>
<p>这两种的区别？</p>
<p>Last-Modified精度只能到秒，但是性能更好。</p>
<p>ETag更精细，但是性能不如前者，因为文件变化都要重新计算hash值。</p>
<p><a name="heading_26">  19.  什么是xss攻击？如何防范 </p>
<p><code> </code>XSS指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>如何防范？</p>
</li>
<li><p>前端对表单提交，敏感字符进行转义，例如”&lt;” , “/“ 等</p>
</li>
<li><p>前端防范不一定是绝对安全的，因为可以抓包篡改</p>
</li>
<li><p>核心是后台进行处理，比如转义</p>
<p><a name="heading_27">  20.  什么是csrf攻击？如何防范 </p>
<p>Csrf又叫跨站请求伪造，一般需要借助XSS产生的漏洞。</p>
<p>必须你在访问淘宝  taobao.com， 网站有个评论区。</p>
<p>有黑客在评论区评论内容如下， taobao.com?payxxxtoyyy  接口大意是将你的钱转给我</p>
<p>然后你不小心点到了，因为你在taobao.com这个域名下有cookie，所以这个接口会认为你已经登录了，支付成功。</p>
<p>还有一种钓鱼网站，比如域名是 xxxxxx.com, 在这个域名有一个图片点击之后连接是 taobao.com?payxxxtoyyy， 也会进行支付，因为你很有可能之前登录过淘宝，浏览器本地也存有你的cookie。</p>
<p>那如何防范呢？</p>
</li>
<li><p>堵住XSS漏洞</p>
</li>
<li><p>在http header中添加token校验</p>
</li>
<li><p>校验请求http reffer</p>
<p><a name="heading_28">  21.  什么是websocket? </p>
<p> WebSocket是HTML5出的东西（协议）。<br>首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.008.png"></p>
<p>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么 在 HTTP1.0 中 ，这次HTTP请求就结束了。<br>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。<br>但是请记住     Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是 被动 的，不能主动发起。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。WebSocket 允许服务器端与客户端进行全双工（f  l-duplex）的通信。举例来说，HTTP 协议有点像发电子邮件，发出后必须等待对方回信；WebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p>
<p>其他特点包括：</p>
<table>
<thead>
<tr>
<th align="left">（1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。（3）数据格式比较轻量，性能开销小，通信高效。（4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax。 （6）协议标识符是ws（如果加密，则为wss，对应 HTTPS 协议），服务器网址就是 URL。</th>
</tr>
</thead>
</table>
<p><a name="heading_29">  22.  Socket和WebSocket的关系？ </p>
<p>socket</p>
</li>
</ol>
<ul>
<li><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输；</p>
</li>
<li><p>Socket是对TCP/IP协议的封装和应用(程序员层面上)；</p>
<p>socket在软件上的体现可以理解为nodejs的内置模块 socket，可以去操作TCP。</p>
<p>它们关系就好像Java和Javascript一样，没有关系。</p>
<p><a name="heading_30">   HTML CSS </p>
<p><a name="heading_32">  23.  请说出两种水平垂直居中的方法？ </p>
<p><code>   </code>Flex布局设置居中</p>
<p><code>     </code>1. 给父盒子设置属性</p>
</li>
<li><p><code> </code>display: flex;写在父元素上这就是定义了一个伸缩容器</p>
</li>
<li><p>justify-content：center  设置主轴对齐方式为居中，默认是横轴</p>
</li>
<li><p>align-items：center 设置纵轴对齐方式为居中，默认是纵轴</p>
</li>
</ul>
<p><code>     </code>2.给子盒子设置属性</p>
<p><code>           </code>给容器设置 display: flex; 子项设置 margin: auto;</p>
<p><code>     </code>3. 绝对定位设置居中</p>
<p><code>          </code>容器设置position: relative。子元素设置 position: absolute; left: 50%; top: 50%;     transfrom: translate(-50%, -50%);</p>
<p><code>           </code>优点就是不用关心子元素的长和宽，但是这种方法兼容性依赖translate2d的兼容性</p>
<p><code>     </code>4.绝对定位另一种方法</p>
<p><code>           </code>需要给子元素设置 position: absolute; 设置固定宽度和高度;top、left、bottom、right都设置为0; margin设置为auto；也能实现垂直水平居中。</p>
<p><a name="heading_33">  24.  nth-child和nth-of-type的区别 </p>
<p>1、:nth-child() 选择器</p>
<p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型，n 可以是数字、关键词或公式。</p>
<table>
<thead>
<tr>
<th align="left">JavaScript <div> <code>    </code><span></span> <code>    </code><span></span> <code>    </code><div></div> <code>    </code><span></span> <code>    </code><span></span> </div></th>
</tr>
</thead>
</table>
<p>2、:nth-of-type(n)</p>
<p>:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素，n 可以是数字、关键词或公式。</p>
<p><a name="heading_34">  25.  请描述一下浏览器渲染的过程？ </p>
<p>当浏览器的 网络线程 收到 HTML 文档后，会产生一个 渲染任务 ，并将其传递给 渲染主线程 的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启 渲染流程 。 整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.009.png"></p>
<table>
<thead>
<tr>
<th align="left">1. 渲染的第一步是 解析 HTML文档    2. 解析的过程中遇到HTML元素会解析HTML元素最终生成DOM树   3. 解析的过程中遇到style标签、link元素、行内样式等CSS样式，会解析CSS生成CSSOM树</th>
</tr>
</thead>
</table>
<p>CSS不会阻塞HTML解析</p>
<p>如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为 下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 </p>
<p>JS会阻塞HTML解析</p>
<p>如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将JS代码解析执行完成后，才能继续解析 HTML。 这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停 。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>此时，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.010.png"></p>
<table>
<thead>
<tr>
<th align="left">渲染的下一步是 样式计算    主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。   在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px    这一步完成后，会得到一棵带有样式的 DOM树。</th>
</tr>
</thead>
</table>
<p>![ref1]</p>
<table>
<thead>
<tr>
<th align="left">接下来是 布局 ， 布局完成后会得到布局树 layout。   布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的 几何信息 。例如节点的宽高、相对包含块的位置。</th>
</tr>
</thead>
</table>
<p>![ref1]</p>
<table>
<thead>
<tr>
<th align="left">下一步是 分层 Layer    主线程会使用一套复杂的策略对整个布局树中进行分层。   分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。   滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。</th>
</tr>
</thead>
</table>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.011.png"></p>
<p>![ref1]</p>
<table>
<thead>
<tr>
<th align="left">再下一步是 绘制 paint    主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。   完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由 合成线程 完成。</th>
</tr>
</thead>
</table>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.012.png"></p>
<p>![ref1]</p>
<p>接下来是合成线程的工作</p>
<table>
<thead>
<tr>
<th align="left">分块 tilling   合成线程首先对每个图层进行分块，将其划分为更多的小区域。</th>
</tr>
</thead>
</table>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.013.png"></p>
<p>分块的工作是交给多个线程同时进行的</p>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.014.png"></p>
<p>![ref1]</p>
<table>
<thead>
<tr>
<th align="left">分块完成后，进入 光栅化 阶段 raster。   合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。   GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。   光栅化的结果，就是一块一块的位图</th>
</tr>
</thead>
</table>
<p><img src="D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.015.png"></p>
<p>你模型的那些顶点在经过各种矩阵变换后也仅仅是顶点。而由顶点构成的图形要在屏幕上显示出来，除了需要顶点的信息以外，还需要确定构成这个图形的所有像素的信息。</p>
<p>![ref1]</p>
<table>
<thead>
<tr>
<th align="left">最后一个阶段就是 画 了 draw   合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。   指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。   变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。   合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</th>
</tr>
</thead>
</table>
<p><a name="heading_35">  26.  什么是回流 reflow？ </p>
<p>![ref2]</p>
<p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了 会影响布局树的操作 后，需要 重新计算布局树 ，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p>
<p><a name="heading_36">  27.  什么是重绘？ </p>
<p>![ref2]</p>
<p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<p><a name="heading_37">  28.  为什么 transform 的效率高？ </p>
<p>![ref2]</p>
<p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个draw阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<p><a name="heading_38">  29.  flex:1 的作用  </p>
<p>首先  flex: 1;  等同于  flex: 1 1 auto; </p>
<p> flex: 1  实际上是三个属性的缩写： flex-grow: 1; flex-shrink: 1 flex-basis: auto; </p>
<p><a name="heading_39">  30.  如何减少回流重绘？ </p>
<ol>
<li><p>尽量使用css属性简写:如：用boder代替boder-width，boder-style，boder-color</p>
</li>
<li><p>批量修改元素样式 比如用：class</p>
</li>
<li><p>尽量避免用table布局(table元素一旦触发回流就会导致table里所有的其它元素回流)</p>
</li>
<li><p>需要创建多个DOM节点时,使用DocumentFragment创建。</p>
</li>
<li><p>尽量不要在for循环里面获取元素的位置或者大小属性，这也会引起回流。一定要获取，最好能利用缓存。</p>
<p><a name="heading_40">  31.  事件分级 DOM0  DOM2的区别？  </p>
<p>DOM事件绑定：</p>
<p>DOM0级事件</p>
<p>特点：所有的浏览器都支持；事件只能注册一次，后面的会覆盖旧的；</p>
<p>注册方式：</p>
<p>（1）在html上添加&lt;div οnclick=”alert(‘hello’)”&gt;</div>，其中this指向自身。</p>
<p>（2） 匿名函数d.οnclick=function(){}，其中 this 指向自身</p>
<p>（3）普通函数 οnclick=”ok()”，相当于动态调用，没有时间参数e的传递。</p>
<p><code> </code>DOM2级事件</p>
<p>注册方式：</p>
<p><code>        </code>添加：addEventListener(event,function,userCapture)</p>
<p>dom0级事件和dom2级事件的区别：</p>
<p>如果分别定义了两个dom0级事件和2个dom2级事件：</p>
<p>dom0级事件会覆盖；</p>
<p>dom2不会覆盖，会依次执行；</p>
<p>dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖。</p>
<p><a name="heading_41">  32.  addEventlistener的参数有哪些？ </p>
</li>
</ol>
<pre><code class="javascript"> | :----------------------------------------------------------- |

- el：事件对象。比如，某个标签，window，document 对象等等。

- type：事件类型，click、mouseenter 等。

- listener：事件处理函数，事件发生时，就会触发该函数运行。

- useCapture：布尔值，规定是否是捕获型，默认为 false（冒泡）。 为true时捕获，false时冒泡。因为是可选的，往往也会省略它。

addEventListener() 的第三个参数可为 &#123;&#125; 对象

| Plaintext el.addEventListener(type, listener, &#123; `    `capture: false, // === useCapture `    `once: false,    // 是否设置单次监听,if true，会在调用后自动销毁listener `    `passive: false  // 是否让 阻止默认行为(preventDefa  t()) 失效，if true, 意味着listener永远不远调用preventDefa  t方法 &#125;) // 新增参数的三个属性，默认值都是 false。 |
| :----------------------------------------------------------- |

- true 的触发顺序总是在 false 之前；

- 如果多个均为 true，则外层的触发先于内层；

- 如果多个均为 false，则内层的触发先于外层。

&lt;a name=&quot;heading_42&quot;&gt;  33.  HTML中DOCTYPE的作用？ 

&lt;!DOCTYPE html&gt;是h5的声明。


用于 声明当前HTML版本 ，用来 告知web浏览器该文档使用是哪种 HTML 或者 XHTML 规范来解析页面 ，以便浏览器更加准确的理解页面内容，更加良好地展现内容效果！

只要我们对文档DOCTYPE做了正确的声明，浏览器就会进入 标准模式 ；浏览器会按照 W3C的标准来解析渲染页面 ，在 所有浏览器下显示的样式效果会保持一致 。

如果 不写 ，浏览器会以老旧的“ 怪异模式 ”去渲染页面。 不同浏览器下显示样式效果会不一致。 

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.017.png)

&lt;a name=&quot;heading_43&quot;&gt;  34.  什么是事件委托？ 

“事件代理”就是把原本需要绑定在子元素的响应事件委托给父元素，具体实现过程主要是：利用事件冒泡过程，并且利用事件对象event的target属性精准定位到触发事件的子元素对子元素进行操作。

&lt;a name=&quot;heading_44&quot;&gt;  35.  e.target和e.currentTarget的区别？ 

e.currentTarget始终是监听事件者，即  直接调用addEventlistener 那个节点

e.target是事件的真正发出者， 即 实际触发事件的节点，在click事件中就是 被点击的节点 。

&lt;a name=&quot;heading_45&quot;&gt;  36.  如何获取用户的浏览器内核是什么？ 

[navigator.appCodeName](http://navigator.appCodeName)

&lt;a name=&quot;heading_46&quot;&gt;  37.  为什么inline-block布局的时候存在一个空格的间距？ 

这实际上是换行引起的问题，默认会显示一个空格，所以需要给父级设置font-size=0

| JavaScript &lt;  &gt; `    `   这是一个li       这是另一个li    这是另另一个li  `    `   这是另另另一个li&lt;/li&gt; &lt;/  &gt; |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_47&quot;&gt;  38.  在flex中justify-content的作用是什么? 

`   `作用：设置同一行子元素在主轴的对齐方式（flex布局默认x轴为主轴，水平向右）

`   `用法：写在父级，作用于子级

&lt;a name=&quot;heading_48&quot;&gt;  39.  如何修改flex布局主轴方向  

flex布局默认：主轴的方向是x轴的方向，水平向右

修改主轴方向使用 flex-direction属性，具体规则如下

&lt;a name=&quot;heading_49&quot;&gt;  40.  position有哪几个属性？ 

`        `1.position: static 静态定位（默认）

`        `2.position:relative 相对定位

`                `参考物：元素的初始位置

`                `特点：不影响元素本身特性，元素不脱离文档流，相对于原位置进行偏移

`        `3.position:absolute 绝对定位

`                `参考物：距离最近的使用了定位的父级，没有时找body

`                `特点：元素脱离文档流 ，块级元素由内容撑开宽高，清除子集浮动

`        `4.position:fixed 固定定位

`                `参考物：浏览器窗口

`                `特点：清除子集浮动，脱离文档流

`        `5. postion: sticky 粘性定位

`              `参考物：根据用户的滚动位置进行定位

`              `特点：粘性元素根据滚动位置在相对（relative）和固定（fixed）之间切换。起先它会被相对定位，直到在视口中遇到给定的偏移位置为止 - 然后将其“粘贴”在适当的位置（比如 position:fixed）。

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.018.png)

https://blog.csdn.net/JiangLittleBai/article/details/108653463

&lt;a name=&quot;heading_50&quot;&gt;  41.  浮动和绝对定位的区别？ 

浮动元素清除浮动之后会撑开父元素。

绝对定位脱离了文档流，不会撑开父元素

&lt;a name=&quot;heading_51&quot;&gt;  42.  对行内元素设置margin-top生效吗？ 

不生效，只有左右margin生效

&lt;a name=&quot;heading_52&quot;&gt;  43.  知道外边距重叠吗？如何解决？ 

两个元素，上面的元素margin botton 30px, 下面的元素margin top 20px。

实际最终两个元素间距30px，而不是50px。这个就是外边距重叠。

怎么解决？ 创建BFC即可。

&lt;a name=&quot;heading_53&quot;&gt;  44.  什么是BFC呢？ 

BFC（块格式化上下文）是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。简单来说，BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素¹²。

创建 BFC 的常用方式有以下几种：

1. 浮动元素（元素的 float 不是 none，指定 float 为 left 或者 right 就可以创建 BFC）。

2. 绝对定位元素（元素的 position 为 absolute 或 fixed）。

3. display: inline-block，display: table-cell，display: flex，display: inline-flex。

4. overflow 指定除了 visible 的值¹。

 这些方式都可以创建一个独立的块格式化上下文，使得容器内部的元素布局不会影响到外部元素。

 &lt;a name=&quot;heading_54&quot;&gt;  45.  浏览器下载资源是并行还是串行的？ 

 并行，最多支持6个

 &lt;a name=&quot;heading_55&quot;&gt;  46.  了解过webp吗？ 

 WebP 是一种现代的图片格式，用于在 web 上提供更好的有损和无损压缩图片。使用 WebP，网站管理员和网页开发人员可以创建更小、更丰富的图片，使网页更快。WebP 无损图像比 PNG 图像小 26%。¹

 有损 WebP 压缩使用预测编码对图像进行编码，这种方法与 VP8 视频编解码器用于压缩视频关键帧的方法相同。预测编码使用相邻块的像素值来预测块中的值，然后仅对差异进行编码。¹

 无损 WebP 压缩使用已经看到的图像片段来精确重建新像素。如果没有找到有趣的匹配，它还可以使用本地调色板。¹

 &lt;a name=&quot;heading_56&quot;&gt;  47.  html使用的字符集是什么？有什么特点？ 

 utf-8是由unicode演变而来的。

 通用性强，空间占用合理。

 计算机诞生 ASC编码，一百多个。

 Abcdef             老虎              西班牙语

 123456 - 100    20000 30000    

 UTF-8 是一种针对 Unicode 的可变长度字符编码。由于 Unicode 包含了世界上几乎所有的字符，因此 UTF-8 支持世界上几乎所有国家和地区的语言。

 &lt;a name=&quot;heading_57&quot;&gt;  48.  什么是雪碧图？作用和原理了解吗？ 

 把小图片利用工具合成一张，使用的时候通过css的background控制位置进行展示。

 可以节省网络请求数量。

 &lt;a name=&quot;heading_58&quot;&gt;  49.  display:none和visible:hidden的区别？ 

 一个占位一个不占位。

  visible:hidden占位 

  display:none不占位 

 &lt;a name=&quot;heading_59&quot;&gt;  50.  css中的伪元素是什么？有什么作用？ 

 CSS 中常用的伪元素有：

- ::before：在元素内容前面插入内容。

- ::after：在元素内容后面插入内容。

- ::first-letter：选择文本的首字母。

- ::first-line：选择文本的首行。

- ::selection：选择用户选中的文本。

这些伪元素可以用来添加一些选择器的特殊效果，例如向文本的首行或首字母设置特殊样式，或者在元素内容前后插入新内容。

&lt;a name=&quot;heading_60&quot;&gt;  51.  flex布局可以设置item子元素的顺序吗？ 

可以

可以使用 CSS 的 order 属性来控制 flex 容器中项目的顺序。默认情况下，项目的 order 值为 0，你可以为项目设置一个正数或负数的 order 值来改变它们的顺序。具有较小 order 值的项目会排在前面。

&lt;a name=&quot;heading_61&quot;&gt;  52.  background-size有哪些属性？ 

background-size 属性用于指定背景图片的大小。它可以接受以下值：

- auto：默认值。保持背景图片的原始尺寸。

- &lt;length&gt;：可以使用长度单位（如 px、em 等）来指定背景图片的宽度和高度。

- &lt;percentage&gt;：可以使用百分比来指定背景图片的宽度和高度，相对于背景区域的大小。

- cover：将背景图片缩放，使其完全覆盖背景区域，同时保持宽高比不变。如果背景图片和背景区域的宽高比不同，那么背景图片将被裁剪以适应背景区域。（图片会被裁剪，显示全）

- contain：将背景图片缩放，使其完全适应背景区域，同时保持宽高比不变。如果背景图片和背景区域的宽高比不同，那么背景区域将被留白。（图片将展示完全）

&lt;a name=&quot;heading_62&quot;&gt;  53.  伪元素和伪类的区别是什么？  

伪元素和伪类都是 CSS 中的选择器，它们都允许你在不改变 HTML 结构的情况下为特定元素或元素的一部分应用样式。

伪类用于根据元素的状态来选择元素，例如鼠标悬停状态（:hover）、选中状态（:checked）或是否被访问过（:visited）等。伪类通常用于为元素添加一些交互效果。

伪元素用于创建一些不在文档树中的元素，并为它们应用样式。例如，你可以使用 ::before 和 ::after 伪元素在元素内容前后插入新内容，或者使用 ::first-letter 和 ::first-line 伪元素为文本的首字母或首行设置特殊样式。

总之，伪类和伪元素的主要区别在于它们选择的对象不同：伪类选择的是已经存在于文档树中的元素，而伪元素创建了一些新的元素。

&lt;a name=&quot;heading_63&quot;&gt;  54.  flex的子元素可以浮动吗？ 

不可以，冲突了，还是flex状态

&lt;a name=&quot;heading_64&quot;&gt;  55.  CSS如何实现一条0.5像素的线？    

用scale缩小。

浏览器最小只支持1像素

&lt;a name=&quot;heading_65&quot;&gt;  56.  了解过shadow Dom吗？ 

Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中。它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。这样，你就可以创建一个独立的 DOM 子树，它与主文档隔离开来，拥有自己的样式和脚本。

隔离性很强，但是不太好用，api比较反人类。

Shadow DOM 的一个重要用途是封装。它允许组件拥有自己的“影子” DOM 树，这个树不能被主文档意外访问，可以有本地样式规则等。这样，你就可以创建一个组件，它的内部结构、样式和行为都被隐藏起来，与页面上其他部分隔离开来，避免冲突。¹

应用场景： web components, 微信小程序

&lt;a name=&quot;heading_66&quot;&gt;  57.  可以怎么优化CSS动画性能？     

最核心要开启gpu加速。

requestAnimationFrame,如果用js修改元素的位置，推荐使用这个API。

建议使用requestA

利用css3 translate进行元素移动

在 CSS3 中，可以使用 transform 属性的 translateZ 函数或 translate3d 函数来开启 GPU 加速。这些函数会创建一个新的图层，浏览器会使用 GPU 来渲染这个图层，从而提高性能。

例如，你可以使用以下代码来开启 GPU 加速：

 ```javascript .element &#123; `  `transform: translateZ(0); &#125; |
| :----------------------------------------------------------- |

或者：

 ```javascript .element &#123; `  `transform: translate3d(0, 0, 0); &#125; |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_67&quot;&gt;  58.  有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度，怎么实现？ 

利用css的calc（100% - 100px）

&lt;a name=&quot;heading_68&quot;&gt;  59.  line-height: 120% 和 line-height: 1.2有什么区别？ 

line-height 属性用于指定行高。当你使用百分比值（如 120%）时，行高是相对于该元素的字体大小计算的。例如，如果元素的字体大小为 14px，则 line-height: 120% 等同于 line-height: 16.8px。

当你使用数值（如 1.2）时，行高是相对于该元素的字体大小计算的，但是这个数值会被继承。例如，如果父元素的字体大小为 14px，则 line-height: 1.2 等同于 line-height: 16.8px。但是，如果子元素的字体大小为 18px，则它的行高将为 21.6px（即 18px \* 1.2），而不是继承父元素的 16.8px。

因此，当你使用百分比值时，子元素会继承计算后的行高值；而当你使用数值时，子元素会继承这个数值，并根据自己的字体大小重新计算行高。

&lt;a name=&quot;heading_69&quot;&gt;   React V18  

&lt;a name=&quot;heading_71&quot;&gt;  60.  useSelector的作用？ 

它是react-redux库中的一个方法，它的作用是读取redux store中的某一段数据，更新hooks react组件

1. React

2. Redux

3. React-redux

 &lt;a name=&quot;heading_72&quot;&gt;  61.  useSelector的原理？ 

 useSelector 是 react-redux 的一个 hook，它可以在不使用 connect() 的情况下将函数组件连接到 redux。它的原理是通过 selector 函数得到需要的数据，并且向 store 通过 subscribe 注册回调，在每次 state 发生变化的时候都会重新调用 selector 函数对其返回值使用比较函数进行比较，如果两者不同，就会重新渲染当前组件。

 追问： 那useSelector是如何更新页面的呢？

```javascript const [, forceRender] = useReducer(s =&gt; s + 1, 0) |
 | :----------------------------------------------------------- |

 使用useReducer返回的第二个参数更新页面

 &lt;a name=&quot;heading_73&quot;&gt;  62.  可以说一下React渲染流程吗？ 

 ` `可以将 react 运行的主干逻辑进行概括:

4. 输入: 将每一次更新(如: 新增, 删除, 修改节点之后)视为一次更新需求(目的是要更新DOM节点).

5. 注册调度任务: react-reconciler收到更新需求之后, 并不会立即构造fiber树, 而是去调度中心sched  er注册一个新任务task, 即把更新需求转换成一个task.

6. 执行调度任务(输出): 调度中心sched  er通过任务调度循环来执行task(task的执行过程又回到了react-reconciler包中).

- fiber构造循环是task的实现环节之一, 循环完成之后会构造出最新的 fiber 树.
- commitRoot是task的实现环节之二, 把最新的 fiber 树最终渲染到页面上, task完成.

react 渲染流程分为 render 和 commit 阶段。

render 阶段（是可以打断的、是有优先级的，render有可能执行多次）执行 vdom 转 fiber 的 reconcile，commit 阶段更新 dom，执行 effect 等副作用逻辑。

commit （同步）阶段分为 before mutation（useEffect 宏任务是异步执行的）、mutation(页面更新)、layout (useLayoutEffect) 3 个小阶段。

&lt;a name=&quot;heading_74&quot;&gt;  63.  setState发生了什么？ 

1. 调用enqueueSetState更新入口
2. 调用requestUpdateLane取得本次更新的优先级
3. 此处返回的lanes会作为全局渲染的优先级, 用于fiber树构造过程中. 针对fiber对象或update对象, 只要它们的优先级(如: fiber.lanes和update.lane)比渲染优先级低, 都将会被忽略.
4. 接下来进入更新
5. 更新分为2种情况，是同步更新模式还是并发更新模式。
6. 如果是同步更新模式，将在微任务中进行异步更新。
7. 如果使用到了 useTransition、useDeferredValue等将进入低优先级并发更新模式。这种模式在宏任务中进行异步渲染 

&lt;a name=&quot;heading_75&quot;&gt;  64.  什么是合成事件？   

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.019.png)

React 16.x及以前的合成事件：

1. 事件委托到document；

2. 部分事件还是会绑定到当前元素；

3. 存在React事件和原生事件的映射关系，比如onMouseLeave会映射成原生的mouseout事件；

4. 事件池机制。

 React 17后的合成事件：

5. 事件委托到root；

6. React capture阶段的合成事件提前到原生事件capture阶段执行；

7. 移除事件池机制；

8. 事件有优先级。

 &lt;a name=&quot;heading_76&quot;&gt;  65.  为什么使用合成事件？ 

 浏览器兼容，统一行为，比如事件对象有统一的属性和方法，又比如，移除不想要的点击事件（Firefox右键点击会生成点击事件），再比如无论注册onMouseLeave还是onMouseOut都会映射成原生的mouseout事件；

 多平台适配，ReactNative也能使用；

 实现事件委托，避免大量创建事件监听；

 SyntheticEvent合成事件对象，在新版本，会在react初始化的时候进行实例化。

 &lt;a name=&quot;heading_77&quot;&gt;  66.  Hooks原理是什么？ 

 hook 的数据就是保存在 fiber.memoizedState 的链表上的，每个 hook 对应一个链表节点。

 hook 的执行分为 mountXxx 和 updateXxx 两个阶段，第一次会走 mountXxx，创建 hook 链表，之后执行 updateXxx。

 注意： hooks的链表结构是环状链表。 a=&gt;b=&gt;c=&gt;a， 为什么？React内部方便处理数据结构，进行hooks的遍历。

 &lt;a name=&quot;heading_78&quot;&gt;  67.  为什么不能在Hooks里写判断？ 

 fiber 节点的 memorizedState 就是保存 hooks 数据的地方。

 它是一个通过 next 串联的链表，展开看一下：

 a=&gt;~~b~~=&gt;c=&gt;a

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.020.png)

 函数中有几个hooks就有几个next，如果写判断next链条就断了

 &lt;a name=&quot;heading_79&quot;&gt;  68.  react v18有几种渲染模式 

 2种

 legacy同步

 concurrent 并发模式

 默认是同步模式，没有开启并发更新特性。

 可使用 useTransition、useDeferredValue开启并发更新 

 &lt;a name=&quot;heading_80&quot;&gt;  69.  setState是同步还是异步？ 

 结论： 异步

 分两种情况：

 同步模式，更新是微任务异步。

 并发模式，更新是宏任务异步。宏任务基于 postMessage实现的。为什么不用setTimeout? 因为时间不准确

 &lt;a name=&quot;heading_81&quot;&gt;  70.  fiber的粒度到底是什么？ 

 app、div、span、p 每一个都是独立的fiber对象

 Return  父级

 Child  子集

 sibling  兄弟节点

```javascript function App()&#123; `    `retrun ( `        `&lt;div&gt; `            `&lt;span&gt;xxxxx&lt;/span&gt; `            ` ppppp   `        `&lt;/div&gt; `    `) &#125; |
 | :----------------------------------------------------------- |

 &lt;a name=&quot;heading_82&quot;&gt;  &lt;a name=&quot;heading_83&quot;&gt;  71.  useEffect副作用队列的顺序？ 

 节点层级越深，越靠前

 effect的回调收集过程是倒着收集的。

 从最底层节点，往上收集。

 &lt;a name=&quot;heading_84&quot;&gt;  72.  workInProgressRoot指针的作用是什么？ 

 它是fiber在render阶段遍历的进度的指针，并发任务的暂停和继续就是基于这个指针去做的

 &lt;a name=&quot;heading_85&quot;&gt;  73.  HOOKS解决了什么问题？ 

9. hooks状态复用、逻辑复用。 class组件UI复用，比较臃肿。

10. React官方的理念，并不想把hooks和生命周期混为一谈。你会发现hooks并不能完全和class组件对号入座？

  你说useEffect是代表的didMount?didUpdate?willunmount吗？ 并不完全是

  &lt;a name=&quot;heading_86&quot;&gt;  74.  Redux解决了什么问题？ 

11. 数据状态管理，就像开启了上帝视角，可以数据 =&gt; 视图一一对应

12. 可以实现时间旅行，数据回退

13. 方便调试，利用action和dev-tools

  &lt;a name=&quot;heading_87&quot;&gt;  75.  Redux解决了组件通信吗？ 

  实际上redux的模型并不是组件通信，redux的核心原理实际上是action修改store,store变化引起组件的重新渲染。

  但这是组件通信吗？好像并不是。vue中的$emit好像才更像

  Redux的思想是置顶向下。

  面试： 

  你说它没有通信，它好像确实没有通信。

  你说它通信了，它好像确实也通信了。

  | 重点不是结论，而是你分析这个事情的思路 |
  | :------------------------------------- |

  &lt;a name=&quot;heading_88&quot;&gt;  76.  Redux中间件是什么？ 

  实际上都是利用compose实现了函数返回值的链条，

  换言之，中间件都是对store.dispatch()的增强。

  &lt;a name=&quot;heading_89&quot;&gt;  77.  你用过哪些Redux中间件？ 

14. Redux-thunk

15. Redux-toolkit，这个是主流

16. Redux-saga，大名鼎鼎的Dva就是基于saga封装的，不过现在很少用了

  redux-thunk实际上是加了一层判断，如果action是函数就继续执行这个函数，给函数注入dispatch等参数，函数内部可以继续进行dipatch.

  如果action是对象就直接通过reducer修改store.

  不过redux-thunk对于大型项目还是太简单了,而且写法很繁琐复杂。

  Redux-toolkit更像是一个数据管理中间件解决方案，让action编写更方便，而且底层基于immer不可变数据。

  大大简化了对store的修改。总之，写项目简单了，可以更加专注于业务。

  &lt;a name=&quot;heading_90&quot;&gt;  78.  immer是什么？有什么作用？和immutablejs的区别和应用场景区别是啥？ 

  当我们对一个对象既需要拷贝，拷贝完又要对拷贝完的对象修改时，如果使用浅拷贝，会有一个修改对象的深层属性同时修改原对象深层属性的问题，如果使用深拷贝，当对象的数据层级过深结构过复杂时，但是我们只需要修改一两个属性，却要对整个对象结构进行深拷贝，那么对象结构的很多部分进行的深拷贝，是一种对计算机资源的严重的浪费！所以我们就想要一种按需拷贝的方案，就是需要修改的一小部分结构进行深拷贝，不需要修改的大部分结构进行浅拷贝，immer就实现了这种方案！immutablejs也解决了同样的问题，他们的主要区别在于:

  1、Immer 的 API 非常简单，上手几乎没有难度，同时项目迁移改造也比较容易。immutable-js 上手就复杂的多，使用 immutable-js 的项目迁移或者改造起来会稍微复杂一些。

  2、Immer 需要环境支持 Proxy 和 defineProperty，否则无法使用。但 immutable-js 支持编译为 ES3 代码，适合所有 JS 环境。

  3、Immer 的运行效率受到环境因素影响较大。immutable-js 的效率整体来说比较平稳，但是在转化过程中要先执行 fromJS 和 toJS，所以需要一部分前期效率的成本。

  &lt;a name=&quot;heading_91&quot;&gt;  79.  Context解决了什么题？可以代替Redux吗？ 

  解决了组件跨层级状态传递。

  不可代替redux，context更适合封装复杂组件用，redux更适合管理整个项目数据状态。

  而且context没有时间旅行，不好调试。context容易造成额外渲染，对性能不好。

  &lt;a name=&quot;heading_92&quot;&gt;  80.  React16.8之后新增了哪些生命周期，分别有什么特点？ 

  static getDerivedStateFromProps 静态方法取代了componentWillMount、componnetWilllUpdate、componentWillReceiveProps这个三个钩子，其实就是把那三个钩子的含义融合到了这一个钩子中

  getDerivedStateFromProps(props, state)会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 n  l 则不更新任何内容。

  getSnapshotBeforeUpdate,这里可获取到即将要更新的props和state

  特点:getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。

  &lt;a name=&quot;heading_93&quot;&gt;  81.  React V18严格模式有什么特点？ 

  ①识别不安全的生命周期，有些生命周期会故意执行两次，确保开发人员不要写出错误的代码

  ②关于使用过时字符串 ref API 的警告

  ③关于使用废弃的 findDOMNode 方法的警告

  ④检测意外的副作用

  ⑤检测过时的 context API

  ⑥确保可复用的状态

17. 有些生命周期会执行两次，确保正确的代码，因为fiber架构下，render执行的次数是不确定的

18. 一些废弃方法的警告

  &lt;a name=&quot;heading_94&quot;&gt;  82.  什么是受控组件？ 

  将UI状态完全交给state或者props管理，不允许直接修改value

  &lt;a name=&quot;heading_95&quot;&gt;  83.  Ref有什么特点？forwardRef 呢？有什么区别？ 

  Ref可以获取真实dom实例，或者class组件的组件实例，function组件是没有Ref的。

  forwardRef 是 React 的一个 API，它允许我们从父组件向子组件传递一个 ref，从而让父组件能够访问子组件的 DOM 节点或实例。在编写高阶组件时，forwardRef 能确保 ref 对象被正确的传递到被包装的组件中。

 ```javascript import React, &#123; useRef, forwardRef &#125; from &#39;react&#39;;  const FancyButton = forwardRef((props, ref) =&gt; ( `  `&lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt; `    `&#123;props.children&#125; `  `&lt;/button&gt; ));  function App() &#123; `  `const ref = useRef(n  l);  `  `function handleClick() &#123; `    `ref.current.focus(); `  `&#125;  `  `return ( `    `    `        `&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt; `        `&lt;button onClick=&#123;handleClick&#125;&gt;Focus FancyButton&lt;/button&gt; `    `&lt;/&gt; `  `); &#125; |
  | :----------------------------------------------------------- |

  &lt;a name=&quot;heading_96&quot;&gt;  84.  Usememo和Usecallback的应用场景是什么？有什么区别？ 

  都用于缓存数据，优化性能。

  useMemo缓存的结果是回调函数中return的值，应用场景：用于缓存计算结果的值，需要计算的状态。

  useCallback缓存的结果是函数，应用场景：当函数式组件中的state发生变化时，会触发整个函数组件更新，但是有些函数是没必要更新的，就可以用useCallback缓存起来。

  react渲染的条件，props进行浅比较，如果引用一致，则不会渲染，需要配合React.memo。

  &lt;a name=&quot;heading_97&quot;&gt;  85.  什么是Hoc？ 

  Hoc是一个函数，接受组件为参数，返回一个经过处理的新组件。

  一般封装的过程存在两个问题要解决：

19. ref不一致，可用forwardRef解决

20. class组件static丢失，可用react的第三方插件解决，复制一下即可

  &lt;a name=&quot;heading_98&quot;&gt;  86.  错误边界组件的作用是什么？ 

  错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树¹²³⁴。

21. 可以捕获子组件的错误，自身的错误捕获不到。

22. 子组件的异步方法错误捕获不到

  一般放在项目根组件，或者页面根组件

 ```javascript import React from &#39;react&#39;;  class ErrorBoundary extends React.Component &#123; `  `constructor(props) &#123; `    `super(props); `    `this.state = &#123; hasError: false &#125;; `  `&#125;  `  `static getDerivedStateFromError(error) &#123; `    `return &#123; hasError: true &#125;; `  `&#125;  `  `componentDidCatch(error, errorInfo) &#123; `    `console.log(error, errorInfo); `  `&#125;  `  `render() &#123; `    `if (this.state.hasError) &#123; `      `return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; `    `&#125;  `    `return this.props.children; `  `&#125; &#125;  function BuggyComponent() &#123; `  `throw new Error(&#39;An error occurred!&#39;); &#125;  function App() &#123; `  `return ( `    `&lt;ErrorBoundary&gt; `      `&lt;BuggyComponent /&gt; `    `&lt;/ErrorBoundary&gt; `  `); &#125; |
  | :----------------------------------------------------------- |

  在这个例子中，我们定义了一个 ErrorBoundary 组件，它继承自 React.Component。在这个组件中，我们定义了 getDerivedStateFromError 和 componentDidCatch 这两个生命周期方法。当子组件树中发生错误时，getDerivedStateFromError 方法会被调用，并返回一个新的状态对象，用于更新组件的状态。同时，componentDidCatch 方法也会被调用，并接收到错误对象和错误信息。

  在 render 方法中，我们根据组件的状态来决定渲染内容。如果 hasError 状态为 true，则渲染一个错误信息；否则，渲染子组件。

  在 App 组件中，我们使用 ErrorBoundary 组件来包裹一个有问题的 BuggyComponent 组件。当 BuggyComponent 组件抛出错误时，错误会被 ErrorBoundary 组件捕获，并渲染出错误信息。

  &lt;a name=&quot;heading_99&quot;&gt;  87.  了解过compose函数吗？可以实现一个compose吗？ 

  字节原题

  redux的中间件就是用了这个函数

  通俗来说就是把层层嵌套函数像管道一样连接起来，然后让数据穿过管道连接起来，得到最终的结果。

 ```javascript function compose(...funcs) &#123; `    `if (funcs.length === 0) &#123; `        `return arg =&gt; arg `    `&#125;   `    `if (funcs.length === 1) &#123; `        `return funcs[0] `    `&#125;   `    `return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) &#125; |
  | :----------------------------------------------------------- |

  &lt;a name=&quot;heading_100&quot;&gt;  88.  对React的插槽(Portals)的理解，如何使用，有哪些使用场景 

  React 官方对 Portals 的定义：

  Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案

  Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。

23. 弹出层级方便管理,统一挂载到document下面， z-index

24. 弹窗方便调试

  &lt;a name=&quot;heading_101&quot;&gt;  89.  在React中如何避免不必要的render？ 

  React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：

-  sho  dComponentUpdate 和 PureComponent 

在 React 类组件中，可以利用 sho  dComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。sho  dComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。

-  利用高阶组件 

在函数组件中，并没有 sho  dComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能

-  使用 React.memo配合useMemo 或者useCallback 

React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。

&lt;a name=&quot;heading_102&quot;&gt;  90.  Props为什么是单向的?可以改吗？ 

数据流设计初衷是至上而下的，这样容易管理。

如果倒过来，状态会乱套，不好维护。

&lt;a name=&quot;heading_103&quot;&gt;  91.  React中的diff算法？ 

diff算法基于三个约定。

1. key相同

2. type相同

3. 同层级

 否则都算是新节点。

 abcdefg

 abcdef

 通常我们常说的diff算法，实际上重点在于for循环遍历出来的元素，进行移动的过程。

 在react中对比前后的数组元素，会有一个map数据结构存储老的节点fiber对象。

 如果在遍历新老节点的过程，发现能复用，则从map数据结构中删除老节点。

 剩下则是新节点没有用到的，最后会打上标记，并在commit阶段删除掉。

 &lt;a name=&quot;heading_104&quot;&gt;  92.  React现在有多少hooks 

4. useState

5. useReducer

6. useContext

7. useEffect

8. useLayoutEffect

9. useRef

10. useMemo

11. useCallback

12. useDebugValue

13. useImperativeHandle（控制useRef防止其失控）

14. useEffectEvent（对useEffect能力的补充）

15. useInsertionEffect（对useEffect场景的补充）

16. [useMemoCache](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fp  l%2F25123)（减少性能优化心智负担）

17. useTransition

18. useDeferredValue

19. useMutableSource

20. useSyncExternalStore

21. useId

22. use

23. useCacheRefresh

24. useOptimistic

25. useFormStatus

  &lt;a name=&quot;heading_105&quot;&gt;   JS部分 

  &lt;a name=&quot;heading_107&quot;&gt;  93.  文件上传怎么做？ 

  在前端，可以使用 HTML 的 &lt;input type=&quot;file&quot;&gt; 元素来实现文件上传。当用户选择了一个或多个文件后，你可以使用 JavaScript 来获取这些文件并将它们上传到服务器。

  下面是一个简单的示例，它演示了如何使用 &lt;input type=&quot;file&quot;&gt; 元素和 JavaScript 来实现文件上传：

 ```javascript &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; m  tiple&gt; &lt;button id=&quot;uploadButton&quot;&gt;上传&lt;/button&gt;  &lt;script&gt; `  `const fileInput = document.querySelector(&#39;#fileInput&#39;); `  `const uploadButton = document.querySelector(&#39;#uploadButton&#39;);  `  `uploadButton.addEventListener(&#39;click&#39;, () =&gt; &#123; `    `const files = fileInput.files; `    `if (files.length === 0) &#123; `      `alert(&#39;请选择文件&#39;); `      `return; `    `&#125;  `    `const formData = new FormData(); `    `for (const file of files) &#123; `      `formData.append(&#39;files[]&#39;, file); `    `&#125;  `    `fetch(&#39;/upload&#39;, &#123; `      `method: &#39;POST&#39;, `      `body: formData `    `&#125;)     .then(response =&gt; response.text())     .then(res  t =&gt; &#123; `      `console.log(res  t); `    `&#125;)     .catch(error =&gt; &#123; `      `console.error(error); `    `&#125;); `  `&#125;); &lt;/script&gt; |
  | :----------------------------------------------------------- |

  在上面的代码中，我们使用了一个 &lt;input type=&quot;file&quot;&gt; 元素来让用户选择文件。当用户点击“上传”按钮时，我们会获取用户选择的文件，并使用 FormData 对象将它们添加到表单数据中。然后，我们使用 fetch 函数向服务器发送一个 POST 请求，将表单数据上传到服务器。

  &lt;a name=&quot;heading_108&quot;&gt;  94.  什么是分片上传？ 

  分片上传是一种文件上传技术，它允许将大文件分割成多个较小的片段（通常称为“分片”或“块”），然后将这些片段分别上传到服务器。服务器在接收到所有分片后，会将它们组合成一个完整的文件。

  分片上传有以下优点：

- 可以支持大文件上传。由于文件被分割成多个较小的片段，因此可以避免单次上传文件过大导致的问题。

- 可以提高上传速度。由于每个分片都是独立上传的，因此可以并行上传多个分片，从而提高上传速度。

- 可以支持断点续传。如果某个分片上传失败，可以重新上传这个分片，而不需要重新上传整个文件。

实现分片上传需要前端和后端配合。前端需要将文件分割成多个分片，并将每个分片单独上传到服务器；后端需要接收这些分片，并在接收到所有分片后将它们组合成一个完整的文件。

下面是一个简单的前端分片上传示例：

 ```javascript &lt;input type=&quot;file&quot; id=&quot;fileInput&quot;&gt; &lt;button id=&quot;uploadButton&quot;&gt;上传&lt;/button&gt;  &lt;script&gt; `  `const fileInput = document.querySelector(&#39;#fileInput&#39;); `  `const uploadButton = document.querySelector(&#39;#uploadButton&#39;);  `  `uploadButton.addEventListener(&#39;click&#39;, async () =&gt; &#123; `    `const file = fileInput.files[0]; `    `if (!file) &#123; `      `alert(&#39;请选择文件&#39;); `      `return; `    `&#125;  `    `const chunkSize = 1024 \* 1024; // 每个分片的大小（1MB） `    `const totalChunks = Math.ceil(file.size / chunkSize); // 分片总数  `    `for (let i = 0; i &lt; totalChunks; i++) &#123; `      `const start = i \* chunkSize; `      `const end = Math.min(file.size, start + chunkSize); `      `const chunk = file.slice(start, end);  `      `const formData = new FormData(); `      `formData.append(&#39;file&#39;, chunk); `      `formData.append(&#39;filename&#39;, file.name); `      `formData.append(&#39;chunkIndex&#39;, i); `      `formData.append(&#39;totalChunks&#39;, totalChunks);  `      `await fetch(&#39;/upload&#39;, &#123; `        `method: &#39;POST&#39;, `        `body: formData `      `&#125;); `    `&#125;  `    `alert(&#39;上传完成&#39;); `  `&#125;); &lt;/script&gt; |
| :----------------------------------------------------------- |

在上面的代码中，我们首先获取用户选择的文件，然后计算出分片总数。接着，我们使用一个循环来遍历每个分片，并使用 File 对象的 slice 方法将文件分割成多个分片。

对于每个分片，我们创建一个 FormData 对象，并将分片、文件名、分片索引和分片总数添加到表单数据中。然后，我们使用 fetch 函数向服务器发送一个 POST 请求，将表单数据上传到服务器。

需要注意的是，上面的代码仅仅是一个简单的示例，实际应用中可能需要更多的错误处理和进度显示等功能。此外，后端也需要相应地处理分片上传。

&lt;a name=&quot;heading_109&quot;&gt;  95.  File对象和blob对象的区别？ 

File 对象和 Blob 对象都表示一个二进制数据块，它们都继承自 Blob 类。它们之间的主要区别在于 File 对象除了包含二进制数据外，还包含了文件的元数据（如文件名和修改日期）。

你可以使用 File 对象来表示用户选择的文件，例如通过 &lt;input type=&quot;file&quot;&gt; 元素或拖放操作选择的文件。你也可以使用 File 构造函数来创建一个新的 File 对象，但是这通常不太常用。

Blob 对象通常用于表示一个不与文件系统相关联的二进制数据块。你可以使用 Blob 构造函数来创建一个新的 Blob 对象，或者使用 File 对象的 slice 方法来从文件中获取一个数据块。

总之，File 对象和 Blob 对象都可以用来表示二进制数据，但是 File 对象还包含了文件的元数据，而 Blob 对象则不包含这些信息。

Blob对象是包含File的。

&lt;a name=&quot;heading_110&quot;&gt;  96.  defineProperty的作用是什么 

Object.defineProperty 方法用于在对象上定义一个新属性，或者修改对象上已有的属性。它允许你精确地控制属性的行为，例如属性是否可枚举、可写、可配置等。

下面是一个简单的示例，它演示了如何使用 Object.defineProperty 方法来定义一个新属性：

``` JavaScript
const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;myProperty&#39;, &#123;
    value: 42,
    writable: true,
    enumerable: true,
    configurable: true
&#125;);
console.log(obj.myProperty); // 输出: 42 |


在上面的代码中，我们使用 Object.defineProperty 方法在 obj 对象上定义了一个名为 myProperty 的新属性。我们指定了该属性的值为 42，并且该属性是可写、可枚举和可配置的。

除了直接指定属性的值外，你还可以使用 get 和 set 函数来定义一个访问器属性。访问器属性不包含实际的值，而是通过调用 get 和 set 函数来获取和设置值。

下面是一个简单的示例，它演示了如何使用 Object.defineProperty 方法来定义一个访问器属性：

 ```javascript  const obj = &#123; `  `\_myProperty: 0 &#125;;  Object.defineProperty(obj, &#39;myProperty&#39;, &#123; `  `get() &#123; `    `return this.\_myProperty; `  `&#125;, `  `set(value) &#123; `    `this.\_myProperty = value; `  `&#125;, `  `enumerable: true, `  `configurable: true &#125;);  obj.myProperty = 42; console.log(obj.myProperty); // 输出: 42 |
| :----------------------------------------------------------- |

在上面的代码中，我们在 obj 对象上定义了一个名为 myProperty 的访问器属性。当我们获取该属性的值时，会调用 get 函数；当我们设置该属性的值时，会调用 set 函数。这样，我们就可以精确地控制该属性的行为。

&lt;a name=&quot;heading_111&quot;&gt;  97.  es6 proxy的作用是什么 

Proxy 是 ES6 中新增的一个构造函数，它用于创建一个代理对象，可以拦截并自定义对象的基本操作，例如属性查找、赋值、枚举、函数调用等。

使用 Proxy 可以实现许多高级功能，例如数据绑定、校验、撤销/重做等。下面是一个简单的示例，它演示了如何使用 Proxy 来拦截对象的属性访问：

 ```javascript
const target = &#123; `  `message1: &#39;hello&#39;, `  `message2: &#39;world&#39; &#125;;  const handler = &#123; `  `get: function(target, prop, receiver) &#123; `    `if (prop === &#39;message2&#39;) &#123; `      `return &#39;everyone&#39;; `    `&#125; `    `return Reflect.get(...arguments); `  `&#125; &#125;;  const proxy = new Proxy(target, handler);  console.log(proxy.message1); // 输出: hello console.log(proxy.message2); // 输出: everyone |
| :----------------------------------------------------------- |

在上面的代码中，我们首先定义了一个目标对象 target 和一个处理器对象 handler。处理器对象中定义了一个 get 方法，用于拦截对目标对象属性的访问。

接着，我们使用 new Proxy(target, handler) 来创建一个代理对象。当我们访问代理对象的属性时，会调用处理器对象中的 get 方法。在这个方法中，我们可以自定义属性访问的行为。

在上面的示例中，当我们访问代理对象的 message2 属性时，处理器对象中的 get 方法会返回 &#39;everyone&#39;，而不是目标对象中实际的值 &#39;world&#39;。这样，我们就可以拦截并自定义对象的属性访问行为。

&lt;a name=&quot;heading_112&quot;&gt;  98.  es6 reflect的作用是什么？ 

Reflect 是 ES6 中新增的一个内置对象，它提供了一组用于拦截 JavaScript 操作的方法。这些方法与 Proxy 处理器对象中的方法相同，可以用来自定义对象的基本操作。

与 Proxy 不同的是，Reflect 不是一个构造函数，不能用来创建对象。它只是一个普通的对象，包含了一组静态方法，这些方法与 Object 对象中的方法类似。

下面是一个简单的示例，它演示了如何使用 Reflect 来获取和设置对象的属性：

 ```javascript const obj = &#123; `  `x: 1, `  `y: 2 &#125;;  console.log(Reflect.get(obj, &#39;x&#39;)); // 输出: 1  Reflect.set(obj, &#39;x&#39;, 3); console.log(obj.x); // 输出: 3 |
| :----------------------------------------------------------- |

Reflect.get 相当于 obj.x

Reflect.set 相当于 obj.x = 3

在上面的代码中，我们使用 Reflect.get(obj, &#39;x&#39;) 来获取 obj 对象的 x 属性。我们也可以使用 Reflect.set(obj, &#39;x&#39;, 3) 来设置 obj 对象的 x 属性。

&lt;a name=&quot;heading_113&quot;&gt;  99.  es6 构造函数super的作用？ 

调用父类的构造函数constructor

&lt;a name=&quot;heading_114&quot;&gt;  100.  es6 class static的作用 

静态方法或者属性，不用实例化就可以访问

 ```javascript class App &#123; `    `static name = &#39;jack&#39; &#125; |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_115&quot;&gt;  101.  for of有什么特点 

for...of 是 ES6 中新增的一种循环语句，它用于遍历可迭代对象（例如数组、字符串、Map、Set 等）中的每个元素。

与传统的 for 循环和 forEach 方法不同，for...of 循环不需要使用索引来访问 元素，而是直接返回元素的值。这使得代码更简洁、易读。

下面是一个简单的示例，它演示了如何使用 for...of 循环来遍历数组中的每个元素：

 ```javascript const array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];  for (const element of array) &#123; `  `console.log(element); &#125; // 输出: // a // b // c |
| :----------------------------------------------------------- |

在上面的代码中，我们使用 for...of 循环来遍历数组中的每个元素。在每次迭代中，我们都可以直接访问数组中的元素，而不需要使用索引。

除了遍历数组外，for...of 循环还可以用来遍历其他可迭代对象，例如字符串、Map、Set 等。例如：

 ```javascript const string = &#39;hello&#39;;  for (const char of string) &#123; `  `console.log(char); &#125; // 输出: // h // e // l // l // o |
| :----------------------------------------------------------- |

在上面的代码中，我们使用 for...of 循环来遍历字符串中的每个字符。

需要注意的是，不是所有对象都可以使用 for...of 循环来遍历。只有实现了迭代器协议的对象才可以使用 for...of 循环来遍历。

&lt;a name=&quot;heading_116&quot;&gt;  102.  for in有什么特点 

for in循环通常用来遍历对象的键名。它遍历的是数组的索引（即键名）¹。但是，它不适合用来遍历数组，因为它会遍历数组所有的可枚举属性.

还会把对象的原型给遍历出来。

&lt;a name=&quot;heading_117&quot;&gt;  103.  什么是es6装饰器 

在ES6中，装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器其实就是一个编译时执行的函数，语法“@函数名”，通常放在类和类方法的定义前面³。

&lt;a name=&quot;heading_118&quot;&gt;  104.  promise.all的特点是什么 

同时执行promise，需要等待全部完成

&lt;a name=&quot;heading_119&quot;&gt;  105.  promise.race的特点是什么 

同时执行Promise，最快的执行完就好，其他的取消

&lt;a name=&quot;heading_120&quot;&gt;  106.  promise有几种状态 

Promise对象有三种状态：pending（等待中）、f  filled（已成功）和rejected（已失败）。当一个Promise对象被创建时，它的状态是pending。当它被解决时，它的状态变为f  filled。当它被拒绝时，它的状态变为rejected。一旦一个Promise对象的状态从pending变为了另一种状态，它就不能再改变状态了。

&lt;a name=&quot;heading_121&quot;&gt;  107.  怎么理解浏览器的宏任务和微任务 

浏览器的宏任务和微任务是指在JavaScript引擎中，任务被分为两种类型：宏任务和微任务。宏任务是由浏览器规定的，例如DOM渲染后触发的setTimeout和setInterval。而微任务是由ES6语法规定的，例如Promise中的then方法。

`  `事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式，实际上现在浏览器中有多种不同类型的task。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

` `整体代码的执行顺序：

`            `1 先把所有的代码直接推入执行栈

`            `2 一条一条从上往下执行  遇到同步代码直接执行掉 遇到异步代码 也只是&quot;打开&quot; 

`            `3 直到当前执行栈清空 

`            `4 清空之后线程会去任务队列里看是否有待执行的任务 先查看微任务队列 如果有就拿到执行栈里执行 执行掉再看微任务队列 直到微任务队列清空 再去看宏任务队列  把宏任务队列中的第一个函数拿到执行栈里执行 执行完之后再去看微任务队列 重复这个过程 直到所有代码都执行完毕 js线程进入闲置状态

&lt;a name=&quot;heading_122&quot;&gt;  108.  console.log是同步还是异步的？ 

console.log是同步的，与异步完全无关。

`        `chrome的控制台出于对性能的考虑，对于引用类型的数据读取存在延迟

`        `控制台默认值读取第一层数据，当你点击展开时，才会重新去堆内存中读取属性值和下一层的数据

&lt;a name=&quot;heading_123&quot;&gt;  109.  weakmap的作用？ 

答：WeakMap是 ES6 中新增的一种集合类型，叫做“弱映射”，由于他的键引用的对象是弱引用，键所指向的对象可以被垃圾回收，可以防止内存泄露。

&lt;a name=&quot;heading_124&quot;&gt;  110.  es6 map数据结构的特点 

①Map是 键值对的集合 ，键值不限于字符串，可以是任意数据类型，解决javascript的对象只能用了符串作为键的问题

②Map通过 set 方法添加成，通过 get 方法来获取成员

③Map也是构造函数，也可以接受一个数组作为参数，但该数组的成员也必须是一个个表示键值对的数组。例如：[[“name”,“Alvin”],[“age”,18]]

④不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。包括Set和Map本身。

⑤如果对同一个键 多次赋值 ，后面的值将 覆盖前面 的值

⑥如果读取一个不存在的键则返回undefined

⑦只有对同一对象的引用，Map才会视为同一个键。也就是说两个对象的 内存地址是一样的 ，才 会被视为是同一个键 。（Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键）

⑧如果Map的键值是一个基本类型（数字，字符串，布尔等），则只要两个值 严格相等=== （类型和值都相等）才算是同一个键，如0和-0就是同一键，而true和&quot;true&quot;则是两个键

⑨undefined 和 n  l是两个不同的键

⑩NaN在Map中被视为同一个键

&lt;a name=&quot;heading_125&quot;&gt;  111.  es6 set数据结构的特点 

①是一个构造函数

② 类数组，元素唯一 、没有重复

（Set 对象是一个类数组对象，它长得就很像数组。

Set 对象存储的值是不重复的，所以我们通常使用它来实现数组去重。

Set 对象存储的数据不是键值对的形式，而且它可以存储任何类型的数据。）

&lt;a name=&quot;heading_126&quot;&gt;  112.  什么是柯里化 

柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。例如，一个接收两个参数的函数可以被柯里化为只接收一个参数的函数，该函数返回一个新函数，该新函数接收第二个参数并返回结果。这样做的好处是可以将多个参数的函数转换为单个参数的函数，从而使其更易于组合和重用。

以下是一个简单的例子：¹

 ```javascript function add(x) &#123; `  `return function(y) &#123; `    `return x + y; `  `&#125;; &#125;  const add5 = add(5); console.log(add5(3)); // 8 |
| :----------------------------------------------------------- |

在这个例子中，我们定义了一个名为add的函数，它接受一个参数x并返回一个新函数。新函数接受另一个参数y并返回x + y的结果。我们使用add(5)创建了一个新函数add5，它将5添加到其输入中。然后我们调用add5(3)，它返回8。

&lt;a name=&quot;heading_127&quot;&gt;  113.  JS有哪些数据类型 

Javascript一共有8种数据类型，其中基本数据类型有7种：Number、String、Boolean、N  l、Undefind、Symbol(es6新增，表示独一无二的值)、Biglnt七种类型，基本数据类型是按值访问的，因为可以直接操作DOM。一种引用类型:Object(包含function、Array、Date)

&lt;a name=&quot;heading_128&quot;&gt;  114.  为什么0.1 + 0.2不是0.3 

因为[计算机硬件](https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6&amp;spm=1001.2101.3001.7020)存储数据时，是以二进制（10101010）形式进行存储的。所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。

` ` 原因：这是由于在计算机的角度计算的是二进制而不是十进制，所以在计算的时候先将十进制转换成二进制，而在转换中部分的十进制的浮点数会变成二进制的无限不循环小数。 

这样再进行运算就会不准确。

解决这个问题一般有两个思路

1. 转成整数在做除法运算

2. 转成字符串自己实现相加逻辑

 &lt;a name=&quot;heading_129&quot;&gt;  115.  new发生了什么？ 

3. 创建一个新的空对象。

4. 将新对象的\_\_proto\_\_属性指向构造函数的prototype属性。

5. 执行构造函数，并将新创建的空对象作为this的值。

6. 如果构造函数返回一个对象，则返回该对象。否则，返回新创建的对象。

 &lt;a name=&quot;heading_130&quot;&gt;  116.  typeof 和 instanceOf区别？ 

 instanceof：用于检测一个对象是否属于某个类或者其子类，返回一个布尔值。typeof：用于检测一个值的数据类型，返回一个字符串，该字符串表示该值的数据类型。需要注意的是，typeof n  l返回的是&quot;object&quot;

 &lt;a name=&quot;heading_131&quot;&gt;  117.  什么是事件冒泡和捕获？ 

 事件执行过程是先捕获再冒泡的。

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.021.png)

 &lt;a name=&quot;heading_132&quot;&gt;  118.  什么是事件委托 

 将事件绑定到父级dom,通过事件的冒泡机制。

 根据event.target获取点击的元素。

 子元素多的情况下，只用绑定一次事件，提升性能。

 &lt;a name=&quot;heading_133&quot;&gt;  119.  split和join的区别？ 

7. split可以将字符串以某个字符分割，转成数组

8. join可以将数组以某个字符拼接在一起

 &lt;a name=&quot;heading_134&quot;&gt;  120.  堆和栈有什么区别 

 基本数据类型存在栈中，对象在堆。

 对象的引用在栈，寻找对象先在栈中取到对象的引用地址，然后根据这个地址找到堆的地址。

 &lt;a name=&quot;heading_135&quot;&gt;  121.  怎么实现深拷贝？ 

 1\.递归调用 

9. 函数

10. 数组

11. Symbol

12. 循环引用

2\.JSON.stringify + JSON.parse 

3\. 第三方插件lodash.cloneDeep

&lt;a name=&quot;heading_136&quot;&gt;  122.  怎么实现浅拷贝 

1. Object.assign()（一维深拷贝，多维浅拷贝）

2. 扩展运算符（对象一维深拷贝，多维浅拷贝）

3. 数组方法实现数组浅拷贝slice，concat（这俩方法都不会改变原数组，里面两个参数都不传就可以实现数组的浅拷贝）

 &lt;a name=&quot;heading_137&quot;&gt;  123.  闭包有什么作用？ 

 延长作用域链

 &lt;a name=&quot;heading_138&quot;&gt;  124.  encodeURL和decodeURL的作用是什么？ 

 encodeURI 函数主要用来对URL 进行转码 它默认采用的是UTF-8编码

 decodeURI用来对encodeURI编码过的URL进行解码

 使用场景：通过URL传中文参数时，服务端后台获取的值往往会出现乱码

 encodeURI和decodeURI是成对来使用的，在浏览器地址栏中有中文字符的话，可能会出现不可预期的错误，所以可以用encodeURI把非英文字符转化为英文编码，decodeURI可以用来把字符还原回来

 &lt;a name=&quot;heading_139&quot;&gt;  125.  window.onload和$(document).ready的区别？ 

 window.onload 是 在 dom 文 档 树 加 载 完 和 所 有 文 件 加 载 完 之 后 执 行 一 个 函 数

 jquery 中有 $().ready(function),在 dom 文档树加载完之后执行一个函数（注意，这里面的文档树加载完不代表全部文件加载完）。

 $(document).ready 要比 window.onload 先执行 （dom树构建出来就加载）

 window.onload 只能出来一次，$(document).ready 可以出现多次

 &lt;a name=&quot;heading_140&quot;&gt;  126.  xhr对象如何发起一个请求？ 

 XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。²

 以下是一个使用XMLHttpRequest对象发起GET请求的示例代码：³

```javascript var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;http://example.com&#39;, true); xhr.onreadystatechange = function() &#123; `  `if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; `    `console.log(xhr.responseText); `  `&#125; &#125;; xhr.send(); |
 | :----------------------------------------------------------- |

 以下是一个使用XMLHttpRequest对象发起POST请求的示例代码：¹

```javascript var xhr = new XMLHttpRequest(); xhr.open(&#39;POST&#39;, &#39;http://example.com&#39;, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); xhr.onreadystatechange = function() &#123; `  `if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; `    `console.log(xhr.responseText); `  `&#125; &#125;; xhr.send(JSON.stringify(&#123;key: &#39;value&#39;&#125;)); |
 | :----------------------------------------------------------- |

 request.readyStatus一共有5中状态：

 0 － （未初始化）还没有调用send()方法

 1 － （载入）已调用send()方法，正在发送请求

 2 － （载入完成）send()方法执行完成，已经接收到全部响应内容

 3 － （交互）正在解析响应内容

 4 － （完成）响应内容解析完成，可以在客户端调用了

 request.status同HTTP的状态

 &lt;a name=&quot;heading_141&quot;&gt;  127.  什么是可迭代对象? 

 在编程中，可迭代对象是指可以通过循环遍历其所有元素的对象。¹在JavaScript中，可迭代（Iterable）对象是数组的泛化。可迭代对象不一定是数组，数组一定是可迭代对象。每个可迭代对象必然包含一个 [Symbol.iterator] 方法属性; 字符串也是可迭代对象。

 &lt;a name=&quot;heading_142&quot;&gt;  128.  如何判断一个对象是不是数组？ 

 1、从构造函数入手，obj instanceof 

 typeof 和 instanceof 都可以用来判断变量，typeof方法返回一个字符串，来表示数据的类型; 但是typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。而instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，返回一个布尔值。

 2\.从原型入手，Array.prototype.isPrototypeOf(obj);

 利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。

 3\.Array.isArray()方法

 4\.根据对象的class属性(类属性)，跨原型链调用toString()方法

 Object.prototype.toString.call()

 &lt;a name=&quot;heading_143&quot;&gt;  129.  Parseint有几个参数? 

 parseInt() 函数可解析一个字符串，并返回一个整数。

 parseInt(string, radix)string 必需，要被解析的字符串。

 radix 可选，表示要解析的数字的基数，该值介于 2 ~ 36 之间。

 &lt;a name=&quot;heading_144&quot;&gt;  130.  什么是 TypedArray 

 TypedArray（类型化数组）对象描述了一个底层的二进制数据缓冲区的类数组视图。TypedArray 定义了如何访问底层的 ArrayBuffer，实际上用于存储数据的数据结构是 ArrayBuffer，没有名为 TypedArray 的全局属性，也没有名为 TypedArray 的构造函数。

 &lt;a name=&quot;heading_145&quot;&gt;  131.  了解过尾递归优化吗? 

 下面是一个例子：

```javascript // Without tail recursion optimization function factorial(n) &#123; `  `if (n === 0) &#123; `    `return 1; `  `&#125; else &#123; `    `return n \* factorial(n - 1); `  `&#125; &#125;  factorial(1000000); // 120  // With tail recursion optimization function factorial(n, acc = 1) &#123; `  `if (n === 0) &#123; `    `return acc; `  `&#125; else &#123; `    `return factorial(n - 1, n \* acc); `  `&#125; &#125;  factorial(5); // 120 |
 | :----------------------------------------------------------- |

 这个例子中，我们可以看到尾递归优化前后的区别。在第一个函数中，每次递归都会创建一个新的栈帧，直到栈溢出。而在第二个函数中，每次递归都会更新参数，而不是创建新的栈帧。这样可以避免栈溢出的问题。¹

 &lt;a name=&quot;heading_146&quot;&gt;  132.  JIT有了解吗? 

 JIT实际上指，JS的编译过程、运行时。

 Just in Time

 在传统的编译语言里，比如JAVA、Go等，是提前编译的，它们的执行是先在本地编译出一个&quot;东西&quot;，然后在放到服务器上运行。

 提前编译的三大过程：

4. 分词/词法分析（Tokenizing/Lexing）

5. 解析/语法分析（Parsing）                        

6. 机器码代码生成

 但是JS是脚本语言，JS是一边编译一边执行的，所以JS会复杂很多。

 例如，在 语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化 等。

 大部分情况下JS编译发生在代码执行前的几微秒（甚至更短！）的时 间内。

 简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。

 &lt;a name=&quot;heading_147&quot;&gt;  133.  defer和async的区别是什么? 

 defer要等到整个页面正常渲染结束，才会执行；

 async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。

  defer是“渲染完再执行”，async是“下载完就执行” 。

 另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。

 &lt;a name=&quot;heading_148&quot;&gt;  134.  commonjs和amd、cmd的区别？ 

 commonjs是nodejs模块化规范

 Amd、cmd和commonjs比较像，已经过时，很少用了

  ES6 Mod  e： 

 静态编译： 在编译的时候就能确定依赖关系，以及输入和输出的变量

 用于：目前浏览器端的默认标准

  CommonJS和ES6 Mod  e区别： 

 ①CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

 ②CommonJS 模块是运行时加载，ES6模块是编译时输出接口

 ③CommonJS 模块的require()是同步加载模块，ES6模块的import命令是异步加载，有一个独立的模块依赖的解析阶段

 &lt;a name=&quot;heading_149&quot;&gt;  135.  async await的原理是什么?  会编译成什么？ 

 async/await 会被编译成 ES5 或者 ES6 的 Promise 对象。async 函数会被编译成一个返回 Promise 对象的函数，而 await 表达式会被编译成 then 方法的调用。² async/await 的实现依赖于编译器类似 yield return 的功能，也就是把原本一个完整的函数拆成状态机。¹

 举个例子，下面的代码：

```javascript async function foo() &#123; `  `const res  t = await bar(); `  `console.log(res  t); &#125; |
 | :----------------------------------------------------------- |

 会被编译成：

```javascript function foo() &#123; `  `return new Promise((resolve, reject) =&gt; &#123; `    `bar().then((res  t) =&gt; &#123; `      `console.log(res  t); `      `resolve(); `    `&#125;).catch(reject); `  `&#125;); &#125; |
 | :----------------------------------------------------------- |

 &lt;a name=&quot;heading_150&quot;&gt;   Vue3 

 &lt;a name=&quot;heading_152&quot;&gt;  136.  vue3为什么要升级proxy,废弃defineProperty 

 Vue.js 3.0 采用了 Proxy 来代替 Object.defineProperty，主要原因是 Proxy 可以直接代理整个对象，包括数组、Map、Set 等等，而 Object.defineProperty 只能对对象的属性进行代理。此外，Proxy 还可以监听到更多的操作，包括属性的删除、原型链上的操作等。这使得 Vue.js 3.0 的响应式系统更加强大和灵活。

7. defineProperty需要递归遍历对象的属性，而且初始化的时候会全部收集完毕

8. proxy直接代理整个对象，而且只有当对象的属性被读取的时候才会进行依赖收集，懒收集

 &lt;a name=&quot;heading_153&quot;&gt;  137.  路由守卫的作用 

 以下是一些 Vue.js 路由守卫的例子：

- 全局前置守卫可以使用 router.beforeEach 注册，会在路由跳转前触发。例如，可以在用户未登录时，跳转到登录页面。

- 全局后置钩子可以使用 router.afterEach 注册，会在每次路由跳转结束后触发。例如，可以在每次路由跳转结束后，记录用户的访问日志。

- 单个路由独享的守卫可以在路由配置上直接定义。例如，可以在某个路由上定义一个 beforeEnter 守卫，来检查用户是否有权限访问该路由。

- 组件级的守卫可以在组件内部直接定义。例如，可以在某个组件内部定义 beforeRouteEnter 守卫，来检查用户是否有权限访问该组件。

&lt;a name=&quot;heading_154&quot;&gt;  138.  Composition API与React Hook很像，区别是什么 

从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制

- 不能在循环、条件、嵌套函数中调用Hook

- 必须确保总是在你的React函数的顶层调用Hook

- useEffect、useMemo等函数必须手动确定依赖关系

而Composition API是基于Vue的响应式系统实现的，与React Hook的相比

- 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢

- Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用

- 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。

&lt;a name=&quot;heading_155&quot;&gt;  139.  什么是虚拟dom 

虚拟dom是对真实dom的补充和增强（抽象），因为在渲染过程中vue需要添加一些属性或者标记，方便内部处理渲染。

&lt;a name=&quot;heading_156&quot;&gt;  140.  为什么要用虚拟DOM 

虚拟 DOM 的作用是为了解决浏览器性能问题而被设计出来的。传统的 DOM 操作很慢，轻微的操作都可能导致页面重新排版，非常耗性能。而虚拟 DOM 可以很好地跟踪当前 DOM 状态，因为它会根据当前数据生成一个描述当前 DOM 结构的虚拟 DOM，然后数据发生变化时，有生成一个新的虚拟 DOM，而两个虚拟 DOM 恰好保存了变化前后的状态。然后通过 diff 算法，计算出当前两个虚拟 DOM 之间的差异，得出一个更好的替换方案。这样就可以避免不必要的 DOM 操作，从而提高页面性能。

1. 性能友好

2. 对真实dom的抽象，更好的去写出优雅的代码

 &lt;a name=&quot;heading_157&quot;&gt;  141.  虚拟DOM真的比真实DOM性能好吗 

 虚拟dom对性能有一个基本的兜底。

 就好像赛车，自动挡和手动的区别。谈到微操，那肯定还是靠手动。但是整体来看虚拟dom的性能够用了

 &lt;a name=&quot;heading_158&quot;&gt;  142.  Vue3 Diff算法的变化 

 Vue2用的是双端交叉对比。

 头=&gt; 头

 头 =&gt; 尾

 尾 =&gt; 尾

 尾 =&gt; 头

 Vue3 算法有一些变化

 头=&gt;头

 尾=&gt; 尾

 剩下部分使用最长递增子序列算法，计算出需要移动的最少元素。相比Vue2牺牲了JS的运算性能，但是减少了Dom元素的移动。

 在浏览器中，DOM移动对性能的影响比JS耗时大得多。

 所以，没有绝对完美的算法。

 &lt;a name=&quot;heading_159&quot;&gt;  143.  Vue中key的作用 

 对数组节点的复用

 &lt;a name=&quot;heading_160&quot;&gt;  144.  为什么不建议用index作为key? 

 在数组节点移动的时候，比如尾部移动到头部，会导致所有元素index都变化

 &lt;a name=&quot;heading_161&quot;&gt;  145.  为什么Vue不使用React的分片更新？ 

 其实这个问题也可以叫做：为什么 Vue 不需要时间分片？对于这个问题其实尤雨溪也在英文社区里回答过，也有前端大牛翻译发布在公众号上，那么下面我也进行一下总结。

 第一，首先时间分片是为了解决 CPU 进行大量计算的问题，因为 React 本身架构的问题，在默认的情况下更新会进行很多的计算，就算使用 React 提供的性能优化 API，进行设置，也会因为开发者本身的问题，依然可能存在过多计算的问题。

 第二，而 Vue 通过响应式依赖跟踪，在默认的情况下可以做到只进行组件树级别的更新计算，而默认下 React 是做不到的（据说 React 已经在进行这方面的优化工作了），再者 Vue 是通过 template 进行编译的，可以在编译的时候进行非常好的性能优化，比如对静态节点进行静态节点提升的优化处理，而通过 JSX 进行编译的 React 是做不到的。

 第三，React 为了解决更新的时候进行过多计算的问题引入了时间分片，但同时又带来了额外的计算开销，就是任务协调的计算，虽然 React 也使用最小堆等的算法进行优化，但相对 Vue 还是多了额外的性能开销，因为 Vue 没有时间分片，所以没有这方面的性能担忧。（时间分片本身就是性能开销）

 第四，根据研究表明，人类的肉眼对 100 毫秒以内的时间并不敏感，所以时间分片只对于处理超过 100 毫秒以上的计算才有很好的收益，而 Vue 的更新计算是很少出现 100 毫秒以上的计算的，所以 Vue 引入时间分片的收益并不划算。

 &lt;a name=&quot;heading_162&quot;&gt;  146.  react为什么不能学习vue3进行静态节点标记优化性能？ 

 因为 React 使用的是 JSX，而 JSX 本质上就是 JS 语言，是具有非常高的动态的，而 Vue 使用的 template 则是给了足够的约束，比如说 Vue 的 template 里面使用了很多特定的标记来做不同的事情，比如说 v-if 就是进行变量判断的，而这些标记也是非常有限的，且表达方式也是跟其他HTML语言标记是有区别的，所以就十分容易进行优化分析；而JSX本质上就是 JS 语言，那么你要做静态分析，实质就是在做JS的静态分析，所以就非常困难，举个例子，Vue 的 template 里面是没有闭包的，而 JSX 里面就有可能存在闭包  

 &lt;a name=&quot;heading_163&quot;&gt;  147.  vue3中setup组件有实例吗？ 

 有的。

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.022.png)

 &lt;a name=&quot;heading_164&quot;&gt;  148.  vue和react的区别？ 

 vue3的setup组件有实例，

 react函数式组件是没有实例的，只有class组件才有

 &lt;a name=&quot;heading_165&quot;&gt;  149.  setup返回的render函数优先级高于template 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.023.png)

 &lt;a name=&quot;heading_166&quot;&gt;  150.  vue3的初始化过程？ 

 核心流程是patch，然后Patch有一个分支，分别处理组件和浏览器原生标签。分别对应processElement和processComponent，从上到下插入，知道处理完成，才把顶层div插入到浏览器。“一次性渲染，而不是一个个一个渲染”

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.024.png)

 &lt;a name=&quot;heading_167&quot;&gt;  151.  vue3中如果给ref传入对象，发生了什么？ 

 其实就是创建reactive

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.025.png)

 &lt;a name=&quot;heading_168&quot;&gt;  152.  vue3中ref是get怎么收集依赖的 

 ref实例化中会有一个dep属性，它是一个set数据结构

 dep会把effect对象收集进去

 同时effect(组件的更新函数)会把dep收集自己的deps属性中，deps是一个数组

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.026.png)

 &lt;a name=&quot;heading_169&quot;&gt;  153.  ref的set做了什么事情？ 

 遍历ref实例中的dep set数据结构，里面是effect，执行effect.sched  er,在微任务中进行更新

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.027.png)

 &lt;a name=&quot;heading_170&quot;&gt;  154.  reactive的初始化过程 

 创建一个weakMap, 对象作为key， 这个对象的代理对象作为值

 然后注入 get和set的Handler

 &lt;a name=&quot;heading_171&quot;&gt;  155.  reactive是怎么get收集依赖的 

 reactive（target1）

 红： 以target1为key，生成一个weakmap，depsmap为值

 黄： 以target1对象的属性为key，生成一个depsmap，dep set为值

 蓝： 蓝色部分就是set数据结构，通过dep set和effect进行双向收集

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.028.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.029.png)

 &lt;a name=&quot;heading_172&quot;&gt;  156.  reactive触发set的流程 

 去targetMap中读取一个set，set中存储的就是这个对象的属性对应，收集的effect对象。

 然后对effect对象进行遍历，执行effect.sched  er在微任务中更新

 &lt;a name=&quot;heading_173&quot;&gt;   Vue2 

 &lt;a name=&quot;heading_175&quot;&gt;  157.  请描述一下依赖收集的过程 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.030.png)

 &lt;a name=&quot;heading_176&quot;&gt;  158.  请描述Get和Set分别做了什么？ 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.031.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.032.png)

 &lt;a name=&quot;heading_177&quot;&gt;  159.  Dep和Watcher依赖收集的内容到底是什么？ 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.033.png)

3. data中一个属性就是一个dep

4. 动态属性或者动态指令就是一个wacther,绑定的更新函数

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.034.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.035.png)

 &lt;a name=&quot;heading_178&quot;&gt;  160.  Vue2事件是怎么处理的？ 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.036.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.037.png)

 &lt;a name=&quot;heading_179&quot;&gt;  161.  Slot怎么处理的？ 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.038.png)


 &lt;a name=&quot;heading_180&quot;&gt;  162.  nextTick是怎么回事？Vue的更新是同步还是异步的。 

| JavaScript this.data.age = 1 this.data.age = 2 this.data.age = 3  实际页面只会渲染一次 |
| :----------------------------------------------------------- |

 nexttick实际上是微任务的回调，把更新收集在一次，微任务的回调中一起执行

1. Set 修改data中的数据

2. 执行watcher的update

3. pushWatcher(this)

4. 把watcher推入一个queue

5. nextTick(flushQueue)   

6. flushQueue遍历watcher执行run，更新页面（异步  假设是16ms执行的）， 加入一个nexttick回调的执行  （文档中 nexttick的回调）

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.039.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.040.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.041.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.042.png)

 &lt;a name=&quot;heading_181&quot;&gt;  163.  模板中的数据只要被get了就会被收集吗？ 

 不会，必须要在watcher实例化过程中进行get才行，必须要有Dep.target才行

 &lt;a name=&quot;heading_182&quot;&gt;  164.  computed计算属性的原理是什么？ 

 依赖收集，多对多

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.043.png)

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.044.png)

 流程

7. Vue实例初始化的时候，调用initCompile, 对computed的属性进行遍历，挂载到VM实例，然后劫持这个属性

8. 创建get函数， 创建过程实例化 计算Watcher， 返回一个get函数

9. 什么时候触发呢？

10. &#123;&#123;jisuan&#125;&#125;  遍历des  触发jisuan的属性值的读取，触发get

11. 开始计算属性的相互依赖收集

12. 首先我们的deps包含  name和 age 两个dep

13. dep又会收集4个watcher， name的watcher 、age watcher 计算属性watcher（计算age + name） ，更新jisuan视图对应的watcher

  多对多的体现

  2对4

  &lt;a name=&quot;heading_183&quot;&gt;  165.  $watch的原理呢？ 

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.045.png)

14. 在初始化的过程中调用initWatcher

15. initWatcher会去遍历，options中的wacth对象，比如name、age

16. 然后分别调用this.$watch

17. New Wacther

  &lt;a name=&quot;heading_184&quot;&gt;  166.  Vue中有几种类型的watcher 

  User watch， computed watch， data中绑定的watch

  &lt;a name=&quot;heading_185&quot;&gt;  167.  请描述一下Diff算法的详细过程? 

  Diff时间复杂度是O（n）

18. type一定要相同

19. 层级要一致

20. key一定要相同

  [A,B,C,D]  =&gt; [B,C,D,A]

  真正拉开差距，得聊怎么移动元素。

  简单Diff算法

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.046.png)

  遇到这种情况需要移动3次，很浪费性能

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.047.png)

  此时就出现了Vue2中双端交叉指针

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.048.png)

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.049.png)

  &lt;a name=&quot;heading_186&quot;&gt;  168.  keep-alive的原理是什么？ 

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.050.png)

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.051.png)

  第一步：获取到keep-alive包裹的第一个组件以及它的组件名称

  第二步：判断此组件名称是否能被白名单、黑名单匹配，如果不能被白名单匹配 || 能被黑名单匹配，则直接返回VNode，不往下执行，如果不符合，则往下执行第三步

  第三步：根据组件ID、tag生成缓存key，并在缓存集合中查找是否已缓存过此组件。如果已缓存过，直接取出缓存组件，并更新缓存key在keys中的位置（这是LRU算法的关键，删除超过max的组件算法，根据组件的使用频繁程度），如果没缓存过，则继续第四步

  第四步：分别在cache、keys中保存此组件以及他的缓存key，并检查数量是否超过max，超过则根据LRU算法进行删除

 ```javascript // src/core/components/keep-alive.js  export defa  t &#123; `  `name: &#39;keep-alive&#39;, `  `abstract: true, // 判断此组件是否需要在渲染成真实DOM `  `props: &#123; `    `include: patternTypes, `    `exclude: patternTypes, `    `max: [String, Number] `  `&#125;, `  `created() &#123; `    `this.cache = Object.create(n  l) // 创建对象来存储  缓存虚拟dom `    `this.keys = [] // 创建数组来存储  缓存key `  `&#125;, `  `mounted() &#123; `    `// 实时监听include、exclude的变动 `    `this.$watch(&#39;include&#39;, val =&gt; &#123; `      `pruneCache(this, name =&gt; matches(val, name)) `    `&#125;) `    `this.$watch(&#39;exclude&#39;, val =&gt; &#123; `      `pruneCache(this, name =&gt; !matches(val, name)) `    `&#125;) `  `&#125;, `  `destroyed() &#123; `    `for (const key in this.cache) &#123; // 删除所有的缓存 `      `pruneCacheEntry(this.cache, key, this.keys) `    `&#125; `  `&#125;, `  `render() &#123; `      `// 下面讲 `  `&#125; &#125; |
  | :----------------------------------------------------------- |

  |JavaScript // src/core/components/keep-alive.js  function pruneCacheEntry ( `  `cache: VNodeCache, `  `key: string, `  `keys: Array&lt;string&gt;, `  `current?: VNode ) &#123; `  `const cached = cache[key] `  `if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123; `    `cached.componentInstance.$destroy() // 执行组件的destory钩子函数 `  `&#125; `  `cache[key] = n  l  // 设为n  l `  `remove(keys, key) // 删除对应的元素 &#125;|
  | :- |

  |JavaScript // src/core/components/keep-alive.js  render() &#123; `  `const slot = this.$slots.defa  t `  `const vnode: VNode = getFirstComponentChild(slot) // 找到第一个子组件对象 `  `const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions `  `if (componentOptions) &#123; // 存在组件参数 `    `// check pattern `    `const name: ?string = getComponentName(componentOptions) // 组件名 `    `const &#123; include, exclude &#125; = this `    `if ( // 条件匹配 `      `// not included `      `(include &amp;&amp; (!name || !matches(include, name))) || `      `// excluded `      `(exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) `    `) &#123; `      `return vnode `    `&#125;  `    `const &#123; cache, keys &#125; = this `    `const key: ?string = vnode.key == n  l // 定义组件的缓存key `      `// same constructor may get registered as different local components `      `// so cid alone is not enough (#3269) `      `? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#39;&#39;) `      `: vnode.key `    `if (cache[key]) &#123; // 已经缓存过该组件 `      `vnode.componentInstance = cache[key].componentInstance `      `// make current key freshest `      `remove(keys, key) `      `keys.push(key) // 调整key排序 `    `&#125; else &#123; `      `cache[key] = vnode // 缓存组件对象 `      `keys.push(key) `      `// prune oldest entry `      `if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; // 超过缓存数限制，将第一个删除 `        `pruneCacheEntry(cache, keys[0], keys, this.\_vnode) `      `&#125; `    `&#125;  `    `vnode.data.keepAlive = true // 渲染和执行被包裹组件的钩子函数需要用到 `  `&#125; `  `return vnode || (slot &amp;&amp; slot[0]) &#125;|
  | :- |

  咱们再来说说被keep-alive包裹着的组件是如何使用缓存的吧。刚刚说了VNode -&gt; 真实DOM是发生在patch的阶段，而其实这也是要细分的：VNode -&gt; 实例化 -&gt; \_update -&gt; 真实DOM，而组件使用缓存的判断就发生在实例化这个阶段，而这个阶段调用的是createComponent函数，那我们就来说说这个函数吧：

 ```javascript // src/core/vdom/patch.js  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123; `  `let i = vnode.data `  `if (isDef(i)) &#123; `    `const isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive      `    `// 初始化 `    `if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123; `      `i(vnode, false /\* hydrating \*/) `    `&#125;  `    `// 更新 `    `if (isDef(vnode.componentInstance)) &#123; `      `initComponent(vnode, insertedVnodeQueue) `      `insert(parentElm, vnode.elm, refElm) // 将缓存的DOM（vnode.elm）插入父元素中 `      `if (isTrue(isReactivated)) &#123; `        `reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) `      `&#125; `      `return true `    `&#125; `  `&#125; &#125; |
  | :----------------------------------------------------------- |

  在第一次加载被包裹组件时，因为keep-alive的render先于包裹组件加载之前执行，所以此时vnode.componentInstance的值是undefined，而keepAlive是true，则代码走到i(vnode, false /\* hydrating \*/)就不往下走了

  再次访问包裹组件时，vnode.componentInstance的值就是已经缓存的组件实例，那么会执行insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的DOM插入到了父元素中。

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.052.png)

  &lt;a name=&quot;heading_187&quot;&gt;  169.  Vue中依赖注入是什么原理？ 

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.053.png)

21. Provide 和 Inject 只能在父子组件之间使用。对于兄弟组件之间的数据共享，建议使用 Vuex 等状态管理工具。

22. Provide 和 Inject 注入的数据是响应式的。如果提供的数据发生变化，那么所有注入了该数据的组件都会相应地更新。

23. Provide 和 Inject 不保证注入顺序。如果多个组件都提供了同一个键名，注入的顺序不确定，可能会导致组件的渲染结果出现意外情况。

24. Provide 和 Inject 不限制嵌套层数。在组件树中，Provide 和 Inject 可以一直循环注入，直到找到对应的数据或方法。

  原理：

25. provider的组件实例化过程会调用initPrivide,会通过mergeOptions把数据挂载自己的VM实例上，挂载到provide属性

26. 子组件实例化过程，如果有inject，则会通过parent属性向上寻找，provide属性，然后拿到数据

  &lt;a name=&quot;heading_188&quot;&gt;  170.  虚拟dom是什么？ 

  假如我有一下html结构

 ```javascript &lt;div id=&quot;virtual-dom&quot;&gt;  Virtual DOM   &lt;   id=&quot;list&quot;&gt; `  `&lt;li class=&quot;item&quot;&gt;Item 1&lt;/li&gt; `  `&lt;li class=&quot;item&quot;&gt;Item 2&lt;/li&gt; `  `&lt;li class=&quot;item&quot;&gt;Item 3&lt;/li&gt; &lt;/  &gt; &lt;div&gt;Hello World&lt;/div&gt; &lt;/div&gt; |
  | :----------------------------------------------------------- |

  |JavaScript /\*\* ` `\* Element virdual-dom 对象定义 ` `\* @param &#123;String&#125; tagName - dom 元素名称 ` `\* @param &#123;Object&#125; props - dom 属性 ` `\* @param &#123;Array&lt;Element|String&gt;&#125; - 子节点 ` `\*/ function Element(tagName, props, children) &#123; `    `this.tagName = tagName `    `this.props = props `    `this.children = children `    `// dom 元素的 key 值，用作唯一标识符 `    `if(props.key)&#123; `       `this.key = props.key `    `&#125; `    `var count = 0 `    `children.forEach(function (child, i) &#123; `        `if (child instanceof Element) &#123; `            `count += child.count `        `&#125; else &#123; `            `children[i] = &#39;&#39; + child `        `&#125; `        `count++ `    `&#125;) `    `// 子元素个数 `    `this.count = count &#125;  function createElement(tagName, props, children)&#123; ` `return new Element(tagName, props, children); &#125;  mod  e.exports = createElement;|
  | :- |

  我们利用打包工具可以帮助我们把 html编译成 这样

 ```javascript var el = require(&quot;./element.js&quot;); var    = el(&#39;div&#39;,&#123;id:&#39;virtual-dom&#39;&#125;,[ `  `el(&#39;p&#39;,&#123;&#125;,[&#39;Virtual DOM&#39;]), `  `el(&#39;  &#39;, &#123; id: &#39;list&#39; &#125;, [ `        `el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 1&#39;]), `        `el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 2&#39;]), `        `el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 3&#39;]) `  `]), `  `el(&#39;div&#39;,&#123;&#125;,[&#39;Hello World&#39;]) ]) |
  | :----------------------------------------------------------- |

  el执行之后是一个对象表示Dom结构, 那么这个对象就是广意上的VDOM。

  虚拟dom，就是json对真实Dom的描述。

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.054.png)

  最后render是如何渲染的呢？ Render 通过el 生成的vdom对象，渲染到页面中

  |JavaScript /\*\* ` `\* render 将virdual-dom 对象渲染为实际 DOM 元素 ` `\*/ Element.prototype.render = function () &#123; `    `var el = document.createElement(this.tagName) `    `var props = this.props `    `// 设置节点的DOM属性 `    `for (var propName in props) &#123; `        `var propValue = props[propName] `        `el.setAttribute(propName, propValue) `    `&#125;  `    `var children = this.children || [] `    `children.forEach(function (child) &#123; `        `var childEl = (child instanceof Element) `            `? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 `            `: document.createTextNode(child) // 如果字符串，只构建文本节点 `        `el.appendChild(childEl) `    `&#125;) `    `return el &#125; |
  | :- |

  那Diff算法是基于什么对比的呢？

  是基于 这个对象 vdom

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.054.png)

  &lt;a name=&quot;heading_189&quot;&gt;   那Vue2中是如何对虚拟dom渲染的呢？ 

  |JavaScript export defa  t class VNode &#123; `  `tag: string | void; `  `data: VNodeData | void; `  `children: ?Array&lt;VNode&gt;; `  `text: string | void; `  `elm: Node | void; `  `ns: string | void; `  `context: Component | void; // rendered in this component&#39;s scope `  `key: string | number | void; `  `componentOptions: VNodeComponentOptions | void; `  `componentInstance: Component | void; // component instance `  `parent: VNode | void; // component placeholder node  `  `// strictly internal `  `raw: boolean; // contains raw HTML? (server only) `  `isStatic: boolean; // hoisted static node `  `isRootInsert: boolean; // necessary for enter transition check `  `isComment: boolean; // empty comment placeholder? `  `isCloned: boolean; // is a cloned node? `  `isOnce: boolean; // is a v-once node? `  `asyncFactory: Function | void; // async component factory function `  `asyncMeta: Object | void; `  `isAsyncPlaceholder: boolean; `  `ssrContext: Object | void; `  `fnContext: Component | void; // real context vm for functional nodes `  `fnOptions: ?ComponentOptions; // for SSR caching `  `devtoolsMeta: ?Object; // used to store functional render context for devtools `  `fnScopeId: ?string; // functional scope id support  `  `constructor ( `    `tag?: string, `    `data?: VNodeData, `    `children?: ?Array&lt;VNode&gt;, `    `text?: string, `    `elm?: Node, `    `context?: Component, `    `componentOptions?: VNodeComponentOptions, `    `asyncFactory?: Function `  `) &#123; `    `this.tag = tag `    `this.data = data `    `this.children = children `    `this.text = text `    `this.elm = elm `    `this.ns = undefined `    `this.context = context `    `this.fnContext = undefined `    `this.fnOptions = undefined `    `this.fnScopeId = undefined `    `this.key = data &amp;&amp; data.key `    `this.componentOptions = componentOptions `    `this.componentInstance = undefined `    `this.parent = undefined `    `this.raw = false `    `this.isStatic = false `    `this.isRootInsert = true `    `this.isComment = false `    `this.isCloned = false `    `this.isOnce = false `    `this.asyncFactory = asyncFactory `    `this.asyncMeta = undefined `    `this.isAsyncPlaceholder = false `  `&#125; &#125;|
  | :- |

  这里千万不要因为 VNode 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如：

- tag 属性即这个vnode的标签属性

- data 属性包含了最后渲染成真实dom节点后，节点上的class，attribute，style以及绑定的事件

- children 属性是vnode的子节点

- text 属性是文本属性

- elm 属性为这个vnode对应的真实dom节点

- key 属性是vnode的标记，在diff过程中可以提高diff的效率

我们在实例化一个 vue 实例，也即 new Vue( ) 时，实际上是执行 

 ```javascript function Vue (options) &#123; `  `if (process.env.NODE\_ENV !== &#39;production&#39; &amp;&amp; `    `!(this instanceof Vue) `  `) &#123; `    `warn(&#39;Vue is a constructor and sho  d be called with the `new` keyword&#39;) `  `&#125; `  `this.\_init(options) &#125; |
| :----------------------------------------------------------- |

 ```javascript `  `Vue.prototype.\_init = function (options?: Object) &#123; `    `const vm: Component = this        `    `// 省略一系列其它初始化的代码        `    `if (vm.$options.el) &#123; `      `console.log(&#39;vm.$options.el:&#39;,vm.$options.el); `      `vm.$mount(vm.$options.el) `    `&#125; `  `&#125; |
| :----------------------------------------------------------- |

|JavaScript Vue.prototype.$mount = function ( `  `el?: string | Element, `  `hydrating?: boolean ): Component &#123; `  `el = el &amp;&amp; inBrowser ? query(el) : undefined `  `return mountComponent(this, el, hydrating) &#125;|
| :- |

 ```javascript export function mountComponent ( `  `vm: Component, `  `el: ?Element, `  `hydrating?: boolean ): Component &#123; `  `vm.$el = el `  `// 省略一系列其它代码 `  `let updateComponent `  `/\* istanb   ignore if \*/ `  `if (process.env.NODE\_ENV !== &#39;production&#39; &amp;&amp; config.performance &amp;&amp; mark) &#123; `    `updateComponent = () =&gt; &#123; `      `// 生成虚拟 vnode    `      `const vnode = vm.\_render() `      `// 更新 DOM `      `vm.\_update(vnode, hydrating)       `    `&#125; `  `&#125; else &#123; `    `updateComponent = () =&gt; &#123; `      `vm.\_update(vm.\_render(), hydrating) `    `&#125; `  `&#125;  `  `// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法   `  `new Watcher(vm, updateComponent, noop, &#123; `    `before () &#123; `      `if (vm.\_isMounted &amp;&amp; !vm.\_isDestroyed) &#123; `        `callHook(vm, &#39;beforeUpdate&#39;) `      `&#125; `    `&#125; `  `&#125;, true /\* isRenderWatcher \*/) `  `hydrating = false  `  `return vm &#125; |
| :----------------------------------------------------------- |

 ```javascript ` `Vue.prototype.\_render = function (): VNode &#123; `    `const vm: Component = this `    `const &#123; render, \_parentVnode &#125; = vm.$options `    `let vnode `    `try &#123; `      `// 省略一系列代码   `      `currentRenderingInstance = vm `      `// 调用 createElement 方法来返回 vnode `      `vnode = render.call(vm.\_renderProxy, vm.$createElement) `    `&#125; catch (e) &#123; `      `handleError(e, vm, `render`)&#123;&#125; `    `&#125; `    `// set parent `    `vnode.parent = \_parentVnode `    `console.log(&quot;vnode...:&quot;,vnode); `    `return vnode `  `&#125; |
| :----------------------------------------------------------- |

完成视图的更新工作事实上就是调用了vm.\_update方法

 ```javascript `  `Vue.prototype.\_update = function (vnode: VNode, hydrating?: boolean) &#123; `    `const vm: Component = this `    `const prevEl = vm.$el `    `const prevVnode = vm.\_vnode `    `const restoreActiveInstance = setActiveInstance(vm) `    `vm.\_vnode = vnode `    `if (!prevVnode) &#123; `      `// 第一个参数为真实的node节点，则为初始化 `      `vm.$el = vm.\_\_patch\_\_(vm.$el, vnode, hydrating, false /\* removeOnly \*/) `    `&#125; else &#123; `      `// 如果需要diff的prevVnode存在，那么对prevVnode和vnode进行diff `      `vm.$el = vm.\_\_patch\_\_(prevVnode, vnode) `    `&#125; `    `restoreActiveInstance() `    `// update \_\_vue\_\_ reference `    `if (prevEl) &#123; `      `prevEl.\_\_vue\_\_ = n  l `    `&#125; `    `if (vm.$el) &#123; `      `vm.$el.\_\_vue\_\_ = vm `    `&#125; `    `// if parent is an HOC, update its $el as well `    `if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent.\_vnode) &#123; `      `vm.$parent.$el = vm.$el `    `&#125; `  `&#125; |
| :----------------------------------------------------------- |

 ```javascript function patch (oldVnode, vnode, hydrating, removeOnly) &#123;     ...... `    `if (isUndef(oldVnode)) &#123; `      `// 当oldVnode不存在时，创建新的节点 `      `isInitialPatch = true `      `createElm(vnode, insertedVnodeQueue) `    `&#125; else &#123; `      `// 对oldVnode和vnode进行diff，并对oldVnode打patch   `      `const isRealElement = isDef(oldVnode.nodeType) `      `if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; `        `// patch existing root node `        `patchVnode(oldVnode, vnode, insertedVnodeQueue, n  l, n  l, removeOnly) `      `&#125;          ...... `  `&#125; &#125; |
| :----------------------------------------------------------- |

在 patch 方法中，我们看到会分为两种情况，一种是当 oldVnode 不存在时，会创建新的节点；另一种则是已经存在 oldVnode ，那么会对 oldVnode 和 vnode 进行 diff 及 patch 的过程。

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.052.png)


&lt;a name=&quot;heading_190&quot;&gt;  171.  SFC的编译过程 

Vue可以直接在浏览器中解析模板

也可以利用工具webpack

这里要分两种情况

1. Html 文件模式   JS运行过程中编译解析的。

2. 和.vue文件模式（webpack）    是在JS运行前，打包工具已经帮助解析好了。

 &lt;a name=&quot;heading_191&quot;&gt;   先看html模式 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.055.png)

 首先编译 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 将它转成Ast

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.056.png)

 三个子元素

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.057.png)

 最后根据ast结构生成，vNode生成函数

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.058.png)

 &lt;a name=&quot;heading_192&quot;&gt;   在看.vue文件 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.059.png)

 经过vue-loader编译成这样

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.060.png)

 其中 render属性是这个

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.061.png)

 

 &lt;a name=&quot;heading_193&quot;&gt;  172.  filter的原理？ 

 在watcher的get过程中，对get的返回值进行二次处理，赋值给this.value

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.062.png)

 &lt;a name=&quot;heading_194&quot;&gt;   Typescript 

 &lt;a name=&quot;heading_196&quot;&gt;  173.  ts有哪些数据类型 

 number / string / boolean / n  l / undefined

 对象

 元组

 联合类型

 Never

 unkonw等

 &lt;a name=&quot;heading_197&quot;&gt;  174.  n  l和undefined有什么区别? 

 在 JavaScript 中，n  l 与 undefined 分别表示“ 这里有值，但是个空值 ”和“ 这里没有值 ”。而在 TypeScript 中，n  l 与 undefined 类型都是 有具体意义的类型 。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 strictN  lChecks 检查的情况下，会 被视作其他类型的子类型 ，比如 string 类型会被认为包含了 n  l 与 undefined 类型。

 &lt;a name=&quot;heading_198&quot;&gt;  175.  void的作用？ 

 TypeScript 的原始类型标注中有 void，这里的 void 用于描述一个内部没有 return 语句，或者没有显式 return 一个值的函数的返回值

 &lt;a name=&quot;heading_199&quot;&gt;  176.  Type 和 interface 

 解决的问题差不多，建议统一起来，我推荐type。

 在TypeScript中，type和interface都可以用来定义类型的别名。然而，它们之间有一些关键的区别。

1. 灵活性和使用范围：type更加灵活，它可以用来定义任意类型的别名，包括原始类型、函数、对象等。相比之下，interface只能用来定义对象类型的别名。

2. 类型组合：type可以使用交叉类型(intersection type)和联合类型(union type)来组合多个类型，而interface不能。

3. 继承：type可以使用继承和扩展类型的语法来继承和扩展另一个类型，而interface不能。

 总的来说，type在灵活性、类型组合和继承方面都优于interface。然而，interface在定义对象类型的别名时具有更明确的作用。

 &lt;a name=&quot;heading_200&quot;&gt;  177.  .d.ts和ts文件有什么区别？ 

 严格上来说没啥区别，只是默认d.ts的文件代码对类型的全局描述，比如一些第三代包导出type类型，用d.ts进行声明

 &lt;a name=&quot;heading_201&quot;&gt;  178.  never是什么类型？ 

 never代表虚无。比如 error对象就是never

 &lt;a name=&quot;heading_202&quot;&gt;  179.  unknown和any的区别 

 any可以给任意类型值赋值，也可以被任意类型赋值。

 unknonw只能被赋值，不能赋值别人。

 &lt;a name=&quot;heading_203&quot;&gt;  180.  类型断言有什么作用？ 

 比如说你一个对象你给了一个type，但是暂时没法设置属性。可以给个断言，避免类型检查报错

 &lt;a name=&quot;heading_204&quot;&gt;  181.  类型别名是什么？ 

 type关键字就是类型别名

 &lt;a name=&quot;heading_205&quot;&gt;  182.  索引类型是什么？ 

 可以定义一个对象

 | TypeScript interface AllStringTypes &#123; `  `[key: string]: string; &#125;  type AllStringTypes = &#123; `  `[key: string]: string; &#125; |
 | :----------------------------------------------------------- |

 &lt;a name=&quot;heading_206&quot;&gt;  183.  泛型的作用？ 

 泛型就是Ts中定义类型的&quot;函数&quot;，接受一个参数T。比如我一个函数接收什么类型，就返回什么类型。就可以使用泛型T

 &lt;a name=&quot;heading_207&quot;&gt;  184.  Ts中的类型层级关系 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.063.png)

 &lt;a name=&quot;heading_208&quot;&gt;  185.  infer关键字有什么用？ 

 实际上相当于泛型的占位符，比如说我们可以在数组中获取某一个位置的类型T。

 &lt;a name=&quot;heading_209&quot;&gt;  186.  Ts有哪些常见的工具类型？ 

 | TypeScript type Partial&lt;T&gt; = &#123; `    `[P in keyof T]?: T[P]; &#125;;  type Required&lt;T&gt; = &#123; `    `[P in keyof T]-?: T[P]; &#125;;  type Readonly&lt;T&gt; = &#123; `    `readonly [P in keyof T]: T[P]; &#125;;  type Record&lt;K extends keyof any, T&gt; = &#123; `    `[P in K]: T; &#125;;  type Pick&lt;T, K extends keyof T&gt; = &#123; `    `[P in K]: T[P]; &#125;;  type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;  type Extract&lt;T, U&gt; = T extends U ? T : never;  type Exclude&lt;T, U&gt; = T extends U ? never : T; |
 | :----------------------------------------------------------- |

 &lt;a name=&quot;heading_210&quot;&gt;  187.  returnType的作用？ 

 它可以获取函数的返回值类型

 &lt;a name=&quot;heading_211&quot;&gt;  188.  你怎么理解逆变和协变？ 

 | TypeScript class Animal &#123; `    `asPet() &#123; &#125; &#125;  // 狗 class Dog extends Animal &#123; `    `bark() &#123; &#125; &#125;  // 柯基 class Corgi extends Dog &#123; `    `cute() &#123; &#125; &#125;  type DogFactory = (args: Animal) =&gt; Corgi;  function transformDogAndBark(dogFactory: DogFactory) &#123; `    `const dog = dogFactory(new Dog()); `    `dog.bark(); &#125; |
 | :----------------------------------------------------------- |

 | // 参数类型允许为 Dog 的父类型，不允许为 Dog 的子类型。   // 返回值类型允许为 Dog 的子类型，不允许为 Dog 的父类型。      // 逆变和协变   // 函数类型的参数类型使用子类型逆变的方式确定是否成立,   // 返回值使用子类型协变的方式确定是否成立. |
 | :----------------------------------------------------------- |

 &lt;a name=&quot;heading_212&quot;&gt;   Vite工程化 

 &lt;a name=&quot;heading_214&quot;&gt;  189.  commonjs是什么？ 

 nodejs模块化规范

 exports和require

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.064.png)

 &lt;a name=&quot;heading_215&quot;&gt;  190.  什么是UMD 

 UMD（Universal Mod  e Definition）是一种通用模块定义规范，它集结了CommonJs、CMD、AMD的规范于一身，允许同一个代码模块在使用CommonJs、CMD或AMD的项目中运行。

 UMD不是库，我们通过webpack和vite打包出来的产物，可以支持amd或commonjs或es6mod  e的规范。

 UMD打出来的代码可以在各个环境去跑，通用性很强，需要在打包工具中进行配置。

 &lt;a name=&quot;heading_216&quot;&gt;  191.  es6 mod  e的特点 

 浏览器原生支持，需要在本地起一个dev server提供静态资源能力。

 为什么es6不能打印export,commonjs可以？

 es6 mod  e是浏览器静态编译，JS执行前就准备好了。

 commonjs也是执行前准备好，但是原理是通过函数包装的方式，注入变量。

 &lt;a name=&quot;heading_217&quot;&gt;  192.  peerDependencies在package.json中的作用 

 peerDependencies在npm中可以帮助管理项目的依赖关系。它指定了项目需要的其他库或插件的版本号或范围，以确保项目可以在正确的环境中运行并正常工作。

 简单来说，如果一个库或插件列出了它的peerDependencies，那么当其他项目引用它时，npm会自动安装这个库或插件及其所需的依赖项，确保项目可以正常运行。这样可以避免因缺少依赖项而导致的问题，也可以避免重复安装相同的依赖项。

 &lt;a name=&quot;heading_218&quot;&gt;  193.  Vite在开发环境是不进行Ts类型检查的 

 Vite 之所以不把类型检查作为转换过程的一部分，是因为这两项工作在本质上是不同的。转译可以在每个文件的基础上进行，与 Vite 的按需编译模式完全吻合。相比之下，类型检查需要了解整个模块图。把类型检查塞进 Vite 的转换管道，将不可避免地损害 Vite 的速度优势。

 &lt;a name=&quot;heading_219&quot;&gt;  194.  这行代码的作用？ 

 | TypeScript /// &lt;reference types=&quot;vite/client&quot; /&gt; |
 | :-------------------------------------------------- |

 Vite内部定义的一些全局的类型定义，比如对css、图片等资源的处理

 &lt;a name=&quot;heading_220&quot;&gt;  195.  d.ts和ts文件有区别吗？ 

 实际上没啥区别

 

 &lt;a name=&quot;heading_221&quot;&gt;  196.  什么是postcss？ 

 他对标js中的babel，对css进行处理的工具，他的插件系统非常强大，你需要什么功能就可以去引入对应的插件。

 &lt;a name=&quot;heading_222&quot;&gt;  197.  vite中加载js，为什么后面有个t？xxx。防止资源缓存 

| TypeScript http://127.0.0.1:8888/src/main.ts?t=1694359876440 |
| :----------------------------------------------------------- |

 这个代表时间戳

 xxxxx.com/index.js

 xxxxx.com/index.js?t=123

 这两个地址对于浏览器来讲，不一样

 &lt;a name=&quot;heading_223&quot;&gt;  198.  lightningcss的作用，以及配置 

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.065.png)

 &lt;a name=&quot;heading_224&quot;&gt;  199.  预构建 

 预构建的好处，将多个请求合成一个，提升网络性能。

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.066.png)

1. 将请求合并

2. 有一些第三方的Npm包比较古老，预构建会把commonjs的包也转成符合es6 mod  e规范的包去使用

 &lt;a name=&quot;heading_225&quot;&gt;  200.  esbuild为什么只用在开发环境？ 

 它有一些天然的缺陷

3. 不支持es5

4. 对代码拆分支持有限

5. 一些特殊的语法不支持

 所以，开发环境关注性能，生产环境使用rollup弥补这些缺陷。

 &lt;a name=&quot;heading_226&quot;&gt;  201.  vite的esBuild为什么不支持ts进行类型检查？ 

 因为es6 mod  e的核心是按需加载。

 ts的类型检查是项目全量，这样和vite的性能优势相违背。

 所以，esbuild不支持。

 &lt;a name=&quot;heading_227&quot;&gt;  202.  什么是ast？ 

 用一种对象结构去表示JS代码

 JavaScript的AST（抽象语法树）是一种描述代码结构的数据结构。它将源代码转化为一个树形的结构，其中每个节点都表示源代码中的一部分。AST用于表示代码的语法结构，而不需要考虑代码的运行时行为。它常被用于编译器、解释器、代码分析工具和转换器等场景中。

 在JavaScript中，AST由ECMAScript标准定义，并由解析器（如Esprima、Acorn等）从源代码生成。每个节点都具有特定的类型（如“变量声明”、“函数声明”、“二元表达式”等）和属性（如名称、值、操作符等）。

 例如，对于以下的JavaScript代码：

 | TypeScript let x = 10; |
 | :------------------------ |

 其对应的AST可能如下：

 | TypeScript &#123;   `  `&quot;type&quot;: &quot;Program&quot;,   `  `&quot;body&quot;: [   `    `&#123;   `      `&quot;type&quot;: &quot;VariableDeclaration&quot;,   `      `&quot;declarations&quot;: [   `        `&#123;   `          `&quot;type&quot;: &quot;VariableDeclarator&quot;,   `          `&quot;id&quot;: &#123;   `            `&quot;type&quot;: &quot;Identifier&quot;,   `            `&quot;name&quot;: &quot;x&quot;   `          `&#125;,   `          `&quot;init&quot;: &#123;   `            `&quot;type&quot;: &quot;Literal&quot;,   `            `&quot;value&quot;: 10   `          `&#125;   `        `&#125;   `      `],   `      `&quot;kind&quot;: &quot;let&quot;   `    `&#125;   `  `]   &#125; |
 | :----------------------------------------------------------- |

 &lt;a name=&quot;heading_228&quot;&gt;  203.  esbuild为什么快？ 

 传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。但 Terser 其实很慢，主要有 2 个原因。

6. 压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程。

7. JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言。

 因此，Esbuild 这种从头到尾 共享 AST  以及 原生语言编写 的 Minifier 在性能上能够甩开传统工具的好几十倍。

 &lt;a name=&quot;heading_229&quot;&gt;  204.  生产环境百分百全用的rollup吗？ 

 不是。

 比如生产环境代码压缩，就使用了esbuild，因为更快。

 &lt;a name=&quot;heading_230&quot;&gt;  205.  rollup打包的优势在哪里？ 

8. 对css处理更友好、可能还得压缩图片、转base64等esbuild不支持功能

9. 更适合工程化环境，rollup他是老牌的项目打包工具，社区繁荣

10. rollup原生支持打包es6 mod  e的产物，

  &lt;a name=&quot;heading_231&quot;&gt;  206.  splitVendorChunkPlugin的作用？ 

  把第三方包打成一个vendor，和业务代码分开，可以充分利用浏览器缓存。

  index.xxxxx12312312.js

  vendor.xxxxx.js(第三方包的合集)

  &lt;a name=&quot;heading_232&quot;&gt;  207.  为什么生产环境要单独打包出css 

11. css打进js，js会太大

12. 可以利用缓存优化，可能我只改了js，没改样式？

  &lt;a name=&quot;heading_233&quot;&gt;  208.  什么是tree shaking? 

  把没有用到的代码给删掉，但是前提要使用es6 mod  e

  &lt;a name=&quot;heading_234&quot;&gt;  209.  babel插件 

-  编译时工具 。代表工具有@babel/preset-env和@babel/plugin-transform-runtime。

-  运行时基础库 。代表库包括core-js和regenerator-runtime。

他两到底是啥区别？

core-js里面有成千上万种高版本的js方法。

 ```javascript Object.assign |
| :-------------------------- |

编译时工具，就作用之一，就是去选择正确的core-js中的js方法，以及自己也有一些东西。

&lt;a name=&quot;heading_235&quot;&gt;  210.  babel里有个配置 &quot;useBuiltIns&quot;: &quot;usage&quot; 的作用 

| TypeScript &#123; `    `&quot;presets&quot;: [ `      `[ `        `&quot;@babel/preset-env&quot;,  `        `&#123; `          `// 指定兼容的浏览器版本 `          `&quot;targets&quot;: &#123; `            `&quot;ie&quot;: &quot;11&quot; `          `&#125;, `          `// 基础库 core-js 的版本，一般指定为最新的大版本 `          `&quot;corejs&quot;: 3, `          `// Polyfill 注入策略，usage 用到的才需要 `          `&quot;useBuiltIns&quot;: &quot;usage&quot;, `          `// 不将 ES 模块语法转换为其他模块语法 `          `&quot;mod  es&quot;: false `        `&#125; `      `] `    `] `  `&#125; |
| :----------------------------------------------------------- |

为entry或者usage。

entry会引入全量corejs

usage是按需引入，所以选择usage

&lt;a name=&quot;heading_236&quot;&gt;  211.  preset-env方案的局限性 

1. 如果使用新特性，往往是通过基础库(如 core-js)往全局环境添加 Polyfill，如果是开发应用没有任何问题，如果是开发第三方工具库，则很可能会对 全局空间造成污染 。
2. 很多工具函数的实现代码(如上面示例中的\_defineProperty方法)，会在许多文件中重现出现，造成 文件体积冗余 。

&lt;a name=&quot;heading_237&quot;&gt;   Webpack工程化 

&lt;a name=&quot;heading_239&quot;&gt;  212.  assets和static（public）的区别 

 相同点：  assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点

 不相同点： assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。

 建议：  将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。


&lt;a name=&quot;heading_240&quot;&gt;  &lt;a name=&quot;heading_241&quot;&gt;  213.  webpack和vite区别有了解过吗？ 

&lt;a name=&quot;heading_242&quot;&gt;   webpack缺点一。缓慢的服务器启动 

当冷启动开发服务器时，基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用。

 vite改进 

Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间

 webpack缺点2.使用的是node.js去实现 

 vite改进 

- Vite 将会使用 esbuild 预构建依赖。Esbuild 使用 Go 编写，并且比以 Node.js 编写的打包器预构建依赖快 10-100 倍。

 webpack致命缺点3.热更新效率低下 

- 当基于打包器启动时，编辑文件后将重新构建文件本身。显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降。

- 一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块 “热替换” 它自己，而对页面其余部分没有影响。这大大改进了开发体验 - 然而，在实践中我们发现，即使是 HMR 更新速度也会随着应用规模的增长而显著下降。

 vite改进 

- 在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效（大多数时候只需要模块本身），使 HMR 更新始终快速，无论应用的大小。

- Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

 vite缺点1.生态，生态，生态不如webpack 

- wepback牛逼之处在于loader和plugin非常丰富,不过我认为生态只是时间问题，现在的vite,更像是当时刚出来的M1芯片Mac，我当时非常看好M1的Mac，毫不犹豫买了，现在也没什么问题

 vite缺点2.prod环境的构建，目前用的Rollup 

- 原因在于esbuild对于css和代码分割不是很友好

 vite缺点3.还没有被大规模使用,很多问题或者诉求没有真正暴露出来 

- vite真正崛起那一天，是跟vue3有关系的,当vue3广泛开始使用在生产环境的时候，vite也就大概率意味着被大家慢慢开始接受了

&lt;a name=&quot;heading_243&quot;&gt;  214.  npx命令是做什么用的？100    

&lt;a name=&quot;heading_244&quot;&gt;              临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 

`           `可以执行依赖包中的命令，安装完成自动运行

`           `自动加载node\_mod  es中依赖包，不用指定$PATH

`            `可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题

&lt;a name=&quot;heading_245&quot;&gt;  215.  webpack的作用是什么，谈谈你对它的理解？ 

概念：webpack是前端项目工程化的具体解决方案。

主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端JavaScript的兼容性、性能优化等强大的功能。可以将多种静态资源js，css，html等转换成一个静态文件，减少页面请求

好处：把工作的中心放到具体功能的实现上，提高了开发效率和项目的可维护性。

&lt;a name=&quot;heading_246&quot;&gt;  216.  webpack包含哪些核心模块，分别是做什么的？ 

1. entry（入口）：指示 Webpack 从哪个文件开始打包
2. output（输出）：指示 Webpack 打包完的文件输出到哪里去，如何命名等
3. loader（加载器）：webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析
4. plugins（插件）：扩展 Webpack 的功能
5. mode（模式）：主要由两种模式：

- 开发模式：development

- 生产模式：production

&lt;a name=&quot;heading_247&quot;&gt;  217.  webpack的构建流程？ 

依次执行以下三大步骤

6. 初始化流程：从配置文件和shell语句中读取与合并参数，初始化需要使用的插件和配置插件等执行环节所需要的参数

7. 编译构建流程：从Entry发出针对每个Mod  e串行调用对应的Loader去翻译文件内容，再去找到该Mod  e依赖的Mod  e，递归的进行编译处理

8. 输出流程：对编译后的Mod  e组合成Chunk，把chunk转换成文件，输出到文件系统

 &lt;a name=&quot;heading_248&quot;&gt;  218.  loader的作用是什么？有哪些常见的loader   

 webpack默认情况下只认识.js结尾的文件，要打包其它类型的文件，则我们需要在webpack.config.js文件中进行配置，只有通过正确的配置后，当webpack进行打包时才能对其它类型的文件进行正确的打包，那我们最常打包的文件类型有哪些呢？

 1\.file-loader

 file-loader可以用于图片资源的打包配置，当我们只配置loader时，那打包好的图片资源默认是存放在输出文件所在的同级目录下，并且名称格式是：hash值.文件后缀，这样当我们打包多张图片资源时，就无法分清楚哪个打包好的图片资源是由哪张图片打包而来，只能打开该资源才能知道,而且打包好的图片资源是分散的。为了便于区分和统一管理，我们可以在配置项loader后面，再配置一个options配置对象，在这个options配置对象中，我们可以配置图片打包好之后的名称，存放的位置等。

 2\.url-loader

 url-loader的作用跟file-loader差不多，但它比file-loader更强大，它不止能实现file-loader的打包功能，它还比file-loader多一个limit配置项，这个limit配置就是配置图片资源的大小的，即当我们的图片资源大于这个限定值时，则打包后的图片资源放入单独的文件夹进行存放，如果打包后的图片资源小于这个限定值，则直接将该图片资源放入出口js(base64)文件中。

 3\.sass-loader

 当我们打包sass语法编写的css文件时，sass-loader的作用就是将该css文件翻译成纯css语法文件，以便后续打包处理，需要注意的是，在我们需要使用sass-loader时，在安装sass-loader时还需要安装node-sass。

 4\.css-loader

 我们的css打包文件中可能会引入其它的css文件，而css-loader的作用就相当于把这些相互依赖的css文件合并成一个css文件。

 5\.style-loader

 我们需要打包的css文件在经过sass-loader的翻译，css-loader的合并之后，style-loader的作用就是把合并后的css文件挂载到页面的head中来渲染出页面的样式。

 6\.postcss-loader 

 postcss-loader是一个辅助性loader，它是针对css3中新增样式属性而存在的，它可以将css样式文件中的css3样式属性在挂载到页面上时，自动在新样式属性前添加上像-webkit-，-moz-这样的厂商前缀，但是它的使用还需要一个autoprefixer插件配合使用，我们配置postcss-loader的方式跟配置其它loader的方式一样，而引入autoprefixer插件则需要在postcss.config.js文件中引入

 &lt;a name=&quot;heading_249&quot;&gt;  219.  plugin的作用是什么？有哪些常见的plugin？   

 plugin是一个插件，它是对webpack本身的扩展，是一个扩展器，通过插件我们可以扩展 webpack，加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。

 1-HtmlWebpackPlugin

 在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的js 模块引⼊到该 html 中

 2-clean-webpack-plugin

 删除（清理）构建目录

 3-mini-css-extract-plugin

 提取 CSS 到一个单独的文件中

 4-DefinePlugin

 允许在编译时创建配置的全局对象，是一个webpack内置的插件，不需要安装

 &lt;a name=&quot;heading_250&quot;&gt;  220.  什么是bundle，什么是chunk，什么是mod  e     

  mod  e： 非连续的功能块——提供了更小的表面积而不是整个程序。书写良好的mod  es提供了可靠的抽象及封装边界，组成了统一的设计和清晰的目的；模块解析（Mod  eResolution）一个模块可以作为另一个模块的依赖模块，resolver是一个库（libary）用于帮助找不到模块的绝对路径，模块将在resolve.mod  es中指定的所有目录内搜索。

 换句话说就是将一个个js、css拆分成一个个小模块。对于 webpack 来说，项目源码中所有资源（包括 JS、CSS、Image、Font 等等）都属于 mod  e 模块。可以配置指定的 Loader 去处理这些文件。

  chunk：  该webpack专业术语用于webpack内部管理bundling的过程中。bundles由许多的chunks组成——这些chunk有不同的类型（比如entry或child）。通常，chunks直接与bundles相对应。然而，有一些配置可以使其不是一对一的关系；

 `   `产生chunk的三种途径：1：entry入口【可以传递一个字符串，传递数组，传递对象】2：异步加载模块3：代码分割（code spliting）

  bundle：  由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。

 通常我们会弄混这两个概念，以为Chunk就是Bundle，Bundle就是我们最终输出的一个或多个打包文件。确实，大多数情况下，一个Chunk会生产一个Bundle。但有时候也不完全是一对一的关系，比如我们把 devtool配置成’source-map’。然后只有一个入口文件，也不配置代码分割

 [不会还有人不知道mod  e、bundle和chunk的区别吧？_chunk和bundle_一条肥鲶鱼的博客-CSDN博客](https://blog.csdn.net/Jasonslw/article/details/124028176)


 &lt;a name=&quot;heading_251&quot;&gt;  221.  sourceMap的作用？有哪些不同的配置？ 

 sourceMap是一种技术，用于在将JavaScript、CSS或其他代码转换为更高效或更浏览器友好的格式时，帮助调试工具将压缩后的代码映射回其原始源代码，以方便开发者在浏览器中调试代码。

 常见的配置选项：

- source-map: 生成单独的.map文件，可确保在调试过程中的源代码映射准确。

- cheap-source-map: 生成单独的.map文件，但不包括列信息，从而提高编译速度。

- inline-source-map: 将源映射数据包含在输出文件中，不生成.map文件，便于调试。

- cheap-inline-source-map: 类似于inline-source-map，但不包括列信息，以提高编译速度。

- eval: 将源映射作为Data URI嵌入到生成的文件中，并使用eval执行，从而提高编译速度。但这种方式可能会使生成的代码不利于代码审查和调试。

&lt;a name=&quot;heading_252&quot;&gt;  222.  HMR热更新的原理？  

- 通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务

- express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）

- socket server 是一个 websocket 的长连接，双方可以通信

- 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）

- 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）

- 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新

&lt;a name=&quot;heading_253&quot;&gt;  223.  webpack怎么配置单页面或者多页面项目？ 

- 单页直接在entry中指定单页面的入口文件即可，对于多页面来说，如果页面之间有依赖关系可以考虑将entry的值改成一个数组，数组中的每一项是入口文件的地址，并且通过dependOn配置多个入口的依赖关系，一般的，我们也可以直接在entry中配置多个入口文件的键值对。·

&lt;a name=&quot;heading_254&quot;&gt;  224.  babel 相关: polyfill 以及 runtime 区别， ES stage 含义，preset–env 作用等等   

babel 相关: polyfill和runtime的区别，ES stage的含义，preset–env的作用

1\.polyfill 以及 runtime 区别

babel-polyfill 的原理是当运行环境中并没有实现的一些方法，babel-polyfill会做兼容。

babel-runtime 它是将es6编译成es5去执行。我们使用es6的语法来编写，最终会通过babel-runtime编译成es5.也就是说，不管浏览器是否支持ES6，只要是ES6的语法，它都会进行转码成ES5.所以就有很多冗余的代码。

babel-polyfill 它是通过向全局对象和内置对象的prototype上添加方法来实现的。比如运行环境中不支持Array.prototype.find 方法，引入polyfill, 我们就可以使用es6方法来编写了，但是缺点就是会造成全局空间污染。

babel-runtime: 它不会污染全局对象和内置对象的原型，比如说我们需要Promise，我们只需要import Promise from &#39;babel-runtime/core-js/promise’即可，这样不仅避免污染全局对象，而且可以减少不必要的代码。

&lt;a name=&quot;heading_255&quot;&gt;  225.  stage-x：指处于某一阶段的js语言提案 

Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。

Stage 1 - 建议（Proposal）：这是值得跟进的。

Stage 2 - 草案（Draft）：初始规范。

Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。

Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。

&lt;a name=&quot;heading_256&quot;&gt;  226.  理解 babel-preset-env 

babel-preset-es2015: 可以将es6的代码编译成es5.

babel-preset-es2016: 可以将es7的代码编译为es6.

babel-preset-es2017: 可以将es8的代码编译为es7.

babel-preset-latest: 支持现有所有ECMAScript版本的新特性

原文链接：https://blog.csdn.net/formylovetm/article/details/126114080

&lt;a name=&quot;heading_257&quot;&gt;  227.  lazy loading（模块懒加载）的作用什么？ 

懒加载或者按需加载，是一种很好的优化网页或应用的方式，这种方式实际是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即应用或即将引用一些新的代码块。这样加快应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载

借助import()语法异步引入组件，实现文件懒加载：prefetch,preloadingwebpack提倡多写异步代码，提升代码利用率，从而提升页面性能先加载主业务文件

| prefetch利用网络空闲时间，异步加载组件。   import(/\* webpackPrefetch: true / ‘LoginModal’);   preload和主业务文件一起加载，异步加载组件   import(/ webpackPreload: true \*/ ‘ChartingLibrary’); |
| :----------------------------------------------------------- |

补充：

概念：懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。用户滚动到它们之前，可视区外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将网页加载更快。在某些情况下，它还可以帮助减少服务器负载。常适用于图片很多，页面很长的电商网站场景中。

作用：能提升用户的体验，不妨设想下，用户打开像手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数据较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。

减少无效资源的加载：这样能明显减少了服务器的压力和流量，也能够减少浏览器的负担。

防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用

&lt;a name=&quot;heading_258&quot;&gt;  228.  什么是Tree-shaking? 有什么要注意的问题？  

tree-sharking就是去除多余没有用到的代码。

要使用es mod  e引入模块，因为它是静态编译的。不要用require，因为动态的没法分析依赖

&lt;a name=&quot;heading_259&quot;&gt;  229.  webpack-dev-server 和 http服务器的区别       

 dev-server可以帮我们在本地自动启动一个html js css静态资源服务器。 

 http服务器是解析http请求，可以做接口，也可以做静态资源服务器 

&lt;a name=&quot;heading_260&quot;&gt;  230.  webpack、rollup、parcel优劣？  

- webpack适⽤于⼤型复杂的前端站点构建（偏业务）: webpack有强⼤的loader和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发。

- rollup适⽤于基础库的打包（适合第三方库），如vue、d3等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。

- ~~parcel适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。~~

&lt;a name=&quot;heading_261&quot;&gt;  231.  有哪些常⻅的Loader？ 

- file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件

- url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去

- source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试

- image-loader：加载并且压缩图⽚⽂件

- babel-loader：把 ES6 转换成 ES5

- css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性

- style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。

- eslint-loader：通过 ESLint 检查 JavaScript 代码

 注意： 在Webpack中，loader的执行顺序是 从右向左 执行的。因为webpack选择了 compose这样的函数式编程方式 ，这种方式的表达式执行是从右向左的。

&lt;a name=&quot;heading_262&quot;&gt;  232.  有哪些常⻅的Plugin？  

- define-plugin：定义环境变量

- html-webpack-plugin：简化html⽂件创建

- uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码

- webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度

- webpack-bundle-analyzer: 可视化webpack输出⽂件的体积

- mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载

&lt;a name=&quot;heading_263&quot;&gt;  233.  bundle，chunk，mod  e是什么？ 

- bundle：是由webpack打包出来的⽂件；

- chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；

- mod  e：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。

&lt;a name=&quot;heading_264&quot;&gt;  234.  Loader和Plugin的不同？  

不同的作⽤:

-  Loader 直译为&quot;加载器&quot;。Webpack将⼀切⽂件视为模块，但是webpack原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以Loader的作⽤是让webpack拥有了加载和解析⾮JavaScript⽂件的能⼒。

-  Plugin 直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

 不同的⽤法: 

-  Loader 在 mod  e.r  es 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ）

-  Plugin 在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。

&lt;a name=&quot;heading_265&quot;&gt;  235.  webpack的构建流程?  

Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程：

1. 初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数；

2. 开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译；

3. 确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件；

4. 编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；

5. 完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；

6. 输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；

7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。

 在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。

 &lt;a name=&quot;heading_266&quot;&gt;  236.  编写loader或plugin的思路？  

 Loader像⼀个&quot;翻译官&quot;把读到的源⽂件内容转义成新的⽂件内容，并且每个Loader通过链式操作，将源⽂件⼀步步翻译成想要的样⼦。

 编写Loader时要遵循单⼀原则，每个Loader只做⼀种&quot;转义&quot;⼯作。 每个Loader的拿到的是源⽂件内容（source），可以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给webpack。 还可以通过this.async() ⽣成⼀个 callback 函数，再⽤这个callback将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发loader的⼯具函数集——loader-utils 。

 相对于Loader⽽⾔，Plugin的编写就灵活了许多。 webpack在运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

 &lt;a name=&quot;heading_267&quot;&gt;  237.  webpack的热更新是如何做到的？说明其原理？  

 webpack的热更新⼜称热替换（Hot Mod  e Replacement），缩写为HMR。 这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。

 ⾸先要知道server端和client端都做了处理⼯作：

8. 第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。

9. 第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。

10. 第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。

11. 第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。

12. webpack-dev-server/client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了webpack，webpack/hot/dev-server 的⼯作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。

13. HotMod  eReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。

14. 这一步是决定 HMR 成功与否的关键步骤，在该步骤中，HotMod  ePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。

15. 最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。

  &lt;a name=&quot;heading_268&quot;&gt;  238.  如何⽤webpack来优化前端性能？  

  ⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。

-  压缩代码 ：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css

-  利⽤CDN加速 : 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径

-  Tree Shaking : 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现

-  Code Splitting:  将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存

-  提取公共第三⽅库 : SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码

-  性能监控 

-  多进程并发 

&lt;a name=&quot;heading_269&quot;&gt;  239.  如何提⾼webpack的打包速度?  

- happypack: 利⽤进程并⾏编译loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类似的替代者是thread-loader

- 外部扩展(externals): 将不怎么需要更新的第三⽅库脱离webpack打包，不被打⼊bundle中，从⽽减少打包时间，⽐如jQuery⽤script标签引⼊

- dll: 采⽤webpack的 DllPlugin 和 DllReferencePlugin 引⼊dll，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间

- 利⽤缓存: webpack.cache 、babel-loader.cacheDirectory、 HappyPack.cache 都可以利⽤缓存提⾼rebuild效率缩⼩⽂件搜索范围: ⽐如babel-loader插件,如果你的⽂件仅存在于src中,那么可以 include: path.resolve(\_\_dirname,&#39;src&#39;) ,当然绝⼤多数情况下这种操作的提升有限，除⾮不⼩⼼build了node\_mod  es⽂件

&lt;a name=&quot;heading_270&quot;&gt;  240.  如何提⾼webpack的构建速度？  

1. 多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码

2. 通过 externals 配置来提取常⽤库

3. 利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。

4. 使⽤ Happypack 实现多线程加速编译

5. 使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度

6. 使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码

 &lt;a name=&quot;heading_271&quot;&gt;  241.  怎么配置单⻚应⽤？怎么配置多⻚应⽤？  

 单⻚应⽤可以理解为webpack的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述多⻚应⽤的话，可以使⽤webpack的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是：

- 每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套css样式表

- 随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置

&lt;a name=&quot;heading_272&quot;&gt;  242.  webpack 打包是hash码是如何生成的  

7. webpack生态中存在多种计算hash的方式 

- hash
- chunkhash
- contenthash （99%）hash代表每次webpac编译中生成的hash值，所有使用这种方式的文件hash都相同。每次构建都会使webpackiH■算新 的hash。chunkhash基于入口文件及其关联的chun性成，某个文件的改动只会影响与它有关联的chunk的hash值，不 会影响其他文件contenthash根据文件内容创建。当文件内容发生变化时，contenthash发生变化

8. 避免相同随机值

 webpack在计算hash后分割chunk。产生相同随机值可能是因为这些文件属于同一个chunk,可以将某f文雌到独 立的chunk（如放入entry）

 &lt;a name=&quot;heading_273&quot;&gt;  243.  Babel的原理是什么?  

 babel 的转译过程也分为三个阶段，这三步具体是：

-  解析 Parse : 将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；

-  转换 Transform : 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；

-  ⽣成 Generate : 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator。

&lt;a name=&quot;heading_274&quot;&gt;   React Nextjs服务端渲染 SSR 

&lt;a name=&quot;heading_276&quot;&gt;  244.  有了解过服务端渲染的原理吗？ 

实际上服务端渲染的核心，是在nodejs端和前端运行同一段前端渲染相关代码。

在服务端拿到前端这边组件提供的静态方法，在服务端进行请求，组装数据，生成html。

拿redux举个例子，将该组件需要的动态数据以store的形式注入到window对象中。

&lt;a name=&quot;heading_277&quot;&gt;  245.  服务端渲染和单页面渲染有啥区别？ 

服务端渲染是在服务器直接生成html字符串，把页面需要的ui相关html组装好，一次性给到浏览器。

单页面渲染是整个空的div，用js渲染组件

&lt;a name=&quot;heading_278&quot;&gt;  246.  hydrate(水合)的作用是啥？ 

服务端生成的html相关字符串是没有绑定事件的，hydrate也叫注水，给这些ui元素绑定事件。

并且对比，生成的html是否正确。

&lt;a name=&quot;heading_279&quot;&gt;  247.  SSR有什么有点和缺点？ 

优点：利于SEO，尤其是移动端首屏性能好。

缺点： 对技术团队要求高，得有node开发和运维能力，否则遇到瓶颈无人解决将是一场灾难。

&lt;a name=&quot;heading_280&quot;&gt;  248.  如果遇到性能问题怎么办？ 

1. 优雅降级： 比如改成spa单页渲染模式

2. 充钱： 增加服务器配置

3. 利用缓存： 接口缓存、CDN缓存、Redis缓存，服务器缓存

4. 可以使用renderTream将页面以流的形式传输给浏览器

 &lt;a name=&quot;heading_281&quot;&gt;  249.  什么是Rsc 

 全称React Server Components

 它是一种在服务端进行组件渲染的方式，提出的时间不长。和ssr的区别是，ssr是在nodejs端在线解析，返回给前端。

 rsc是在服务端提前编译成一种json结构，浏览器请求时候，可以通过这种方案快速生成前端页面渲染需要的信息。

 以组件为粒度，ssr的粒度是页面。

 目的：减少node端传输到前端的数据量

 &lt;a name=&quot;heading_282&quot;&gt;  250.  react最近新增的离屏渲染是啥？ 

 离屏渲染是 React 中即将推出的一项功能，用于在后台渲染屏幕，而无需额外的性能开销。您可以将其视为[content-visiblity](https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility)[CSS 属性](https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility)的一个版本，不仅适用于 DOM 元素，也适用于 React 组件。

 &lt;a name=&quot;heading_283&quot;&gt;  251.  什么是转换追踪 

 Transition Tracing API 可让您检测[React Transitions](https://react.dev/reference/react/useTransition)何时变慢并调查它们变慢的原因。

 &lt;a name=&quot;heading_284&quot;&gt;  252.  增量构建是什么意思 

 ISR是一种增量构建SSG的方式，

 &lt;a name=&quot;heading_285&quot;&gt;  253.  什么是swr 

 SWR是Next.js官方推荐的数据获取库，它的作用是简化数据获取和管理的过程，提高页面性能和用户体验。SWR的全称是Stale-while-revalidate，它的核心思想是在数据过期之前返回缓存数据，并在后台更新数据，以保证数据的实时性和准确性。

 SWR的主要特点和优势包括：

 - 自动缓存和过期管理：SWR会自动缓存数据，并在数据过期之前返回缓存数据，以提高页面性能和用户体验。
 - 自动重试和错误处理：SWR会自动重试数据获取，并提供错误处理机制，以保证数据的可靠性和稳定性。
 - 简单易用的API：SWR提供了简单易用的API，可以轻松地进行数据获取和管理。
 - 与React Hooks的无缝集成：SWR与React Hooks无缝集成，可以轻松地在React组件中使用。

 SWR的使用方法非常简单，只需要在React组件中使用`useSWR` Hook即可。例如：

```javascript import useSWR from &#39;swr&#39;; function Profile() &#123; `  `const &#123; data, error &#125; = useSWR(&#39;/api/user&#39;, fetch); `  `if (error) return &lt;div&gt;Failed to load user data&lt;/div&gt;; `  `if (!data) return &lt;div&gt;Loading...&lt;/div&gt;; `  `return ( `    `&lt;div&gt; `      `&lt;h1&gt;&#123;data.name&#125;&lt;/h1&gt; `      ` &#123;data.email&#125;   `    `&lt;/div&gt; `  `); &#125; |
 | :----------------------------------------------------------- |

 在这个例子中，我们使用`useSWR` Hook来获取`/api/user`接口的数据，并使用`fetch`函数来进行数据获取。在页面组件中，我们可以根据数据和错误状态来渲染页面内容。

 希望这个回答对您有所帮助！

 &lt;a name=&quot;heading_286&quot;&gt;  254. [ getStaticProps ](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation)[（静态生成）](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticprops-static-generation) 是什么？ 

 组件所需要的数据，在node端静态生成（SSG）

 &lt;a name=&quot;heading_287&quot;&gt;  255. [ getStaticPaths ](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticpaths-static-generation)[（静态生成）](https://www.nextjs.cn/docs/basic-features/data-fetching#getstaticpaths-static-generation) 是什么 

 xxx.com/aaa/:3

 假如我们有一个动态路由的页面，可以指定一些页面生成静态页面

 &lt;a name=&quot;heading_288&quot;&gt;  256. [ getServerSideProps ](https://www.nextjs.cn/docs/basic-features/data-fetching#when-sho  d-i-use-getserversideprops)[是什么? ](https://www.nextjs.cn/docs/basic-features/data-fetching#when-sho  d-i-use-getserversideprops)

 服务端输出给前端的动态数据

 每次访问页面数据一样，node端每次生成新的html用这个

 &lt;a name=&quot;heading_289&quot;&gt;  257.  什么是 Next.js？它的主要特点是什么？ 

 答：Next.js 是一个基于 React 的轻量级框架，用于构建 SSR（服务器端渲染）应用程序和静态网站（SSG）。它提供了许多有用的功能，例如自动代码分割、静态文件服务、CSS 模块支持等等。使用 Next.js 可以帮助开发者更快速地构建出高性能、易于维护的 React 应用程序。

 &lt;a name=&quot;heading_290&quot;&gt;  258.  Next.js 中的数据获取方法有哪些？ 

 答：Next.js 中的数据获取方法有三种：getStaticProps、getStaticPaths 和 getServerSideProps。其中，getStaticProps 和 getStaticPaths 用于在构建时获取数据，而 getServerSideProps 则用于在每个请求时获取数据。

 &lt;a name=&quot;heading_291&quot;&gt;  259.  如何在 Next.js 中实现服务器端渲染（SSR）？ 

 答：在 Next.js 中实现服务器端渲染非常简单，只需要在页面组件中实现一个名为 getServerSideProps 的异步函数，该函数会在每个请求时被调用，并返回一个包含数据的对象。然后，Next.js 会将这些数据注入到页面组件中，并在服务器端渲染出 HTML。

 &lt;a name=&quot;heading_292&quot;&gt;  260.  Next.js 中的路由是如何工作的？ 

 答：在 Next.js 中，路由是基于文件系统的。每个页面都对应一个文件，文件名就是路由路径。例如，pages/index.js 对应的路由路径就是 /，而 pages/about.js 对应的路由路径就是 /about。此外，Next.js 还支持动态路由，可以通过文件名中使用方括号来实现。

 &lt;a name=&quot;heading_293&quot;&gt;  261.  如何在 Next.js 中使用 CSS 模块？ 

 答：在 Next.js 中使用 CSS 模块非常简单，只需要在 CSS 文件中使用 :local() 伪类来定义局部样式，然后在页面组件中使用 import styles from &#39;./styles.mod  e.css&#39; 来导入样式，并通过 className=&#123;styles.className&#125; 来应用样式。

 &lt;a name=&quot;heading_294&quot;&gt;  262.  Next.js 中的静态文件服务是如何实现的？ 

 答：在 Next.js 中，所有位于 public 目录下的文件都会被自动服务于 /public 路径下。例如，public/logo.png 文件可以通过 /public/logo.png 路径来访问。

 &lt;a name=&quot;heading_295&quot;&gt;  263.  如何在 Next.js 中使用动态导入（Dynamic Imports）？ 

 答：在 Next.js 中，可以使用 import() 函数来实现动态导入。例如，可以使用 import(&#39;lodash&#39;) 来动态导入 lodash 库。

 &lt;a name=&quot;heading_296&quot;&gt;  264.  请介绍一下使用 Next.js 开发的一些知名网站或应用程序。 

 答：使用 Next.js 开发的一些知名网站或应用程序包括：H  u、Twitch、HBO、GitHub Docs、TypeScript 官网等等。

 &lt;a name=&quot;heading_297&quot;&gt;  265.  Vercel 公司的创始人 Guillermo Rauch 是 Next.js 的主要贡献者之一，他还是哪个著名 Node.js 框架的创始人？ 

 答：Guillermo Rauch 还是 Socket.IO 和 Meteor 框架的创始人。

 &lt;a name=&quot;heading_298&quot;&gt;  266.  在 Next.js 中，如何实现代码分割（Code Splitting）？ 

 答：在 Next.js 中，代码分割是自动完成的，无需手动配置。Next.js 会根据页面组件的导入情况自动进行代码分割，以确保每个页面只加载必要的代码。


 &lt;a name=&quot;heading_299&quot;&gt;  267.  Next.js 中的 getStaticProps 和 getServerSideProps 有什么区别？ 

 答：getStaticProps 用于在构建时获取数据，而 getServerSideProps 则用于在每个请求时获取数据。getStaticProps 生成的 HTML 可以被缓存，因此适用于不经常变化的数据，而 getServerSideProps 生成的 HTML 则不能被缓存，因此适用于经常变化的数据。

 &lt;a name=&quot;heading_300&quot;&gt;  268.  如何在 Next.js 中使用 TypeScript？ 

 答：在 Next.js 中使用 TypeScript 非常简单，只需要在项目根目录下创建一个名为 tsconfig.json 的 TypeScript 配置文件，并在 pages 目录下使用 .tsx 扩展名来编写页面组件即可。

 &lt;a name=&quot;heading_301&quot;&gt;  269.  如何在 Next.js 中使用自定义服务器？ 

 答：在 Next.js 中使用自定义服务器需要先创建一个名为 server.js 的文件，并在其中使用 createServer 函数来创建一个 HTTP 服务器，并使用 nextApp.getRequestHandler() 函数来获取 Next.js 的请求处理程序。然后，可以使用 server.listen() 函数来启动服务器。

 &lt;a name=&quot;heading_302&quot;&gt;  270.  如何在 Next.js 中使用自定义路由？ 

 答：在 Next.js 中使用自定义路由需要在 pages 目录下创建一个名为 [slug].js 的文件，并在其中使用 useRouter 钩子函数来获取路由参数。然后，可以使用 getStaticPaths 函数来指定所有可能的路由参数，以便 Next.js 可以在构建时生成静态 HTML。

 &lt;a name=&quot;heading_303&quot;&gt;  271.  如何在 Next.js 中使用自定义错误页面？ 

 答：在 Next.js 中使用自定义错误页面需要在 pages 目录下创建一个名为 \_error.js 的文件，并在其中实现一个名为 getInitialProps 的静态方法来获取错误信息。然后，可以在页面组件中使用 props.statusCode 来获取错误状态码，并根据状态码来显示不同的错误页面。

 &lt;a name=&quot;heading_304&quot;&gt;  272.  如何在 Next.js 中使用自定义文档（Document）？ 

 答：在 Next.js 中使用自定义文档需要在 pages 目录下创建一个名为 \_document.js 的文件，并在其中继承自 NextDocument 类，并实现一个名为 render 方法来渲染 HTML 文档。然后，可以在页面组件中使用 &lt;Document&gt; 组件来指定自定义文档。

 &lt;a name=&quot;heading_305&quot;&gt;  273.  如何在 Next.js 中使用自定义 App？ 

 答：在 Next.js 中使用自定义 App 需要在 pages 目录下创建一个名为 \_app.js 的文件，并在其中继承自 NextApp 类，并实现一个名为 render 方法来渲染页面组件。然后，可以在页面组件中使用 &lt;App&gt; 组件来指定自定义 App。

 &lt;a name=&quot;heading_306&quot;&gt;  274.  如何在 Next.js 中使用自定义 webpack 配置？ 

 答：在 Next.js 中使用自定义 webpack 配置需要在项目根目录下创建一个名为 next.config.js 的配置文件，并在其中使用 webpack 配置对象来配置 webpack。例如，可以使用 webpack.plugins 数组来添加自定义插件。

 &lt;a name=&quot;heading_307&quot;&gt;   Vue Nuxt3服务端渲染 

 &lt;a name=&quot;heading_309&quot;&gt;  275.  renderToString()和renderToNodeStream()有啥区别？ 

 一个是直接输出html字符串，一个是将html页面转换成stream流，流会性能更好

 &lt;a name=&quot;heading_310&quot;&gt;  276.  什么是 Nuxt3？ 

 Nuxt3 是 Vue.js 的一个全新的服务端渲染框架。相比于 Nuxt2，Nuxt3 改进了其性能、可维护性和开发体验等方面。Nuxt3 支持 Vue.js 3.x，同时还引入了新的编译器和构建工具。

 &lt;a name=&quot;heading_311&quot;&gt;  277.  Nuxt3 的特点有哪些？ 

 Nuxt3 的特点主要包括：

- 基于 Vue.js 3.x 开发，支持最新的 Vue.js 特性；

- 使用新的编译器和构建工具，提高了性能和可维护性；

- 支持自定义渲染器，可以使用任意的渲染策略；

- 内置支持 TypeScript 和 Sass；

- 灵活的插件系统，可以方便地扩展和定制 Nuxt3；

- 提供了强大的开发工具，如开发服务器和热更新等。

&lt;a name=&quot;heading_312&quot;&gt;  278.  Nuxt3 支持哪些渲染策略？ 

Nuxt3 支持以下几种渲染策略：

- 客户端渲染（CSR）：将 Vue.js 应用打包成一个 JavaScript 文件，通过浏览器下载并解析执行，由客户端负责渲染页面。

- 预渲染（SSG）：在构建时将 Vue.js 应用预渲染成静态 HTML 文件，通过 CDN 或者其他方式进行分发，由客户端负责渲染页面。

- 服务端渲染（SSR）：在服务器端渲染 Vue.js 应用，生成 HTML 页面直接返回给浏览器，客户端只需要执行一些简单的 JavaScript 代码即可完成页面渲染。

&lt;a name=&quot;heading_313&quot;&gt;  279.  Nuxt[服务器引擎 ](https://nuxt.com.cn/docs/getting-started/introduction#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%95%E6%93%8E)[Nitro ](https://nitro.unjs.io/) 

Nuxt服务器引擎[Nitro](https://nitro.unjs.io/)解锁新的全栈功能。

在开发中，它使用Rollup和Node.js工作者进行服务器代码和上下文隔离。它还通过读取server/API/中的文件和从server/middleware/中的服务器中间件生成服务器API。

在生产中，Nitro将你的应用和服务器构建为一个通用的.output目录。这个输出很轻:从任何Node.js模块(除了polyfills)中删除。你可以在任何支持JavaScript的系统上部署这个输出，从Node.js, less server, Workers, Edge-side渲染或纯静态。

&lt;a name=&quot;heading_314&quot;&gt;  280.  Nuxt支持Node和Deno吗？ 

Nuxt应用程序可以部署在Node或Deno服务器上，预呈现为托管在静态环境中，或者部署到无服务器和边缘提供程序。

&lt;a name=&quot;heading_315&quot;&gt;  281.  nuxt需要node什么版本 

16\.11+

&lt;a name=&quot;heading_316&quot;&gt;  282.  什么是Nuxt.js？它有哪些特点和优势？ 

答：Nuxt.js是一个基于Vue.js的通用应用框架，它可以帮助我们快速开发服务器渲染的Vue.js应用。Nuxt.js具有以下特点和优势：

- 自动化的服务器端渲染和优化。

- 基于Vue.js的开发体验和生态系统。

- 支持静态站点生成和动态路由。

- 支持多种数据源和模板引擎。

- 支持自定义布局和页面过渡效果。

&lt;a name=&quot;heading_317&quot;&gt;  283.   Nuxt.js中的asyncData方法是用来做什么的？它的返回值是什么？ 

答：Nuxt.js中的asyncData方法是用来在服务器端获取数据并将其传递给页面组件的方法。它的返回值是一个包含页面组件所需数据的对象。asyncData方法会在服务器端执行，并将返回的数据注入到页面组件的data属性中。

&lt;a name=&quot;heading_318&quot;&gt;  284.  Nuxt.js中的中间件是用来做什么的？如何使用中间件？ 

答：Nuxt.js中的中间件是用来在路由切换之前执行一些操作的方法。例如，我们可以使用中间件来验证用户的身份、检查用户的权限等。要使用中间件，我们可以在nuxt.config.js文件中的router属性中指定中间件，例如：

 ```javascript // nuxt.config.js export defa  t &#123; `  `router: &#123; `    `middleware: [&#39;auth&#39;], `  `&#125;, &#125;; |
| :----------------------------------------------------------- |

在这个例子中，我们指定了一个名为auth的中间件，它将在每个路由切换之前执行。

&lt;a name=&quot;heading_319&quot;&gt;  285.  如何在Nuxt.js中使用CSS模块？ 

答：可以通过在nuxt.config.js文件中的css属性中指定CSS模块来使用CSS模块。例如：

 ```javascript // nuxt.config.js export defa  t &#123; `  `css: [&#39;~/assets/styles/main.css&#39;], `  `build: &#123; `    `postcss: &#123; `      `plugins: &#123; `        `&#39;postcss-import&#39;: &#123;&#125;, `        `&#39;postcss-url&#39;: &#123;&#125;, `        `&#39;postcss-cssnext&#39;: &#123;&#125;, `        `&#39;postcss-nested&#39;: &#123;&#125;, `      `&#125;, `    `&#125;, `  `&#125;, &#125;; |
| :----------------------------------------------------------- |

在这个例子中，我们指定了一个名为main.css的CSS文件，并使用PostCSS插件来处理CSS模块。

&lt;a name=&quot;heading_320&quot;&gt;  286.  如何在Nuxt.js中使用动态路由？ 

答：可以通过在pages目录下创建一个名为\_id.vue的文件来使用动态路由。在这个文件中，我们可以使用asyncData方法来获取动态路由参数，并使用它来获取数据。例如：

 ```javascript &lt;template&gt; `  `&lt;div&gt; `    `&lt;h1&gt;&#123;&#123; post.title &#125;&#125;&lt;/h1&gt; `    ` &#123;&#123; post.content &#125;&#125;   `  `&lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export defa  t &#123; `  `async asyncData(&#123; params &#125;) &#123; `    `const &#123; id &#125; = params; `    `const response = await fetch(`https://api.example.com/posts/$&#123;id&#125;`); `    `const post = await response.json(); `    `return &#123; post &#125;; `  `&#125;, &#125;; &lt;/script&gt; |
| :----------------------------------------------------------- |

在这个例子中，我们使用params对象来获取动态路由参数，并使用它来获取数据。在asyncData方法中，我们使用fetch函数来获取数据，并将其返回给页面组件。

&lt;a name=&quot;heading_321&quot;&gt;  287.  如何在Nuxt.js中使用自定义布局？ 

答：可以通过在layouts目录下创建一个名为defa  t.vue的文件来使用自定义布局。在这个文件中，我们可以使用&lt;nuxt /&gt;标签来渲染页面组件。例如：

| Plain Text &lt;template&gt; `  `&lt;div&gt; `    `&lt;header&gt; `      `&lt;nav&gt; `        `&lt;  &gt; `          `   &lt;nuxt-link to=&quot;/&quot;&gt;Home&lt;/nuxt-link&gt;&lt;/li&gt; `          `   &lt;nuxt-link to=&quot;/about&quot;&gt;About&lt;/nuxt-link&gt;&lt;/li&gt; `          `   &lt;nuxt-link to=&quot;/contact&quot;&gt;Contact&lt;/nuxt-link&gt;&lt;/li&gt; `        `&lt;/  &gt; `      `&lt;/nav&gt; `    `&lt;/header&gt; `    `&lt;main&gt; `      `&lt;nuxt /&gt; `    `&lt;/main&gt; `    `&lt;footer&gt; `      ` &amp;copy; 2021 My Website   `    `&lt;/footer&gt; `  `&lt;/div&gt; &lt;/template&gt; |
| :----------------------------------------------------------- |

在这个例子中，我们创建了一个名为defa  t.vue的布局文件，并在其中使用&lt;nuxt /&gt;标签来渲染页面组件。在页面组件中，我们可以使用layout属性来指定使用的布局文件，例如：

| Plain Text &lt;template&gt; `  `&lt;div&gt; `    `&lt;h1&gt;About Us&lt;/h1&gt; `    ` We are a team of developers who love Nuxt.js!   `  `&lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export defa  t &#123; `  `layout: &#39;defa  t&#39;, &#125;; &lt;/script&gt; |
| :----------------------------------------------------------- |

在这个例子中，我们指定了一个名为defa  t的布局文件，它将用于渲染这个页面组件。

&lt;a name=&quot;heading_322&quot;&gt;  288.  如何在Nuxt.js中使用自定义错误页面？ 

答：可以通过在layouts目录下创建一个名为error.vue的文件来使用自定义错误页面。在这个文件中，我们可以使用&lt;nuxt /&gt;标签来渲染错误信息。例如：

| Plain Text &lt;template&gt; `  `&lt;div&gt; `    `&lt;h1&gt;&#123;&#123; error.statusCode &#125;&#125;&lt;/h1&gt; `    ` &#123;&#123; error.message &#125;&#125;   `  `&lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export defa  t &#123; `  `props: [&#39;error&#39;], &#125;; &lt;/script&gt; |
| :----------------------------------------------------------- |

在这个例子中，我们创建了一个名为error.vue的布局文件，并在其中使用props属性来接收错误信息。在nuxt.config.js文件中，我们可以使用error属性来指定使用的错误页面，例如：

 ```javascript // nuxt.config.js export defa  t &#123; `  `error: &#123; `    `statusCode: 404, `    `message: &#39;Page not found&#39;, `  `&#125;, &#125;; |
| :----------------------------------------------------------- |

在这个例子中，我们指定了一个状态码为404的错误页面，并提供了一个错误信息。

&lt;a name=&quot;heading_323&quot;&gt;  289.  如何在Nuxt.js中使用自定义插件？ 

答：可以通过在plugins目录下创建一个名为my-plugin.js的文件来使用自定义插件。在这个文件中，我们可以定义一个全局的Vue.js插件，并将其注册到Nuxt.js应用中。例如：

 ```javascript // plugins/my-plugin.js import Vue from &#39;vue&#39;;  Vue.prototype.$myPlugin = function () &#123; `  `console.log(&#39;Hello from my plugin!&#39;); &#125;; |
| :----------------------------------------------------------- |

在这个例子中，我们定义了一个名为$myPlugin的全局Vue.js插件，并将其注册到Nuxt.js应用中。在页面组件中，我们可以使用this.$myPlugin()方法来调用这个插件。

&lt;a name=&quot;heading_324&quot;&gt;  290.  如何在Nuxt.js中使用自定义模板引擎？ 

答：可以通过在nuxt.config.js文件中的build属性中指定模板引擎来使用自定义模板引擎。例如：

 ```javascript // nuxt.config.js export defa  t &#123; `  `build: &#123; `    `extend(config, &#123; isDev, isClient &#125;) &#123; `      `config.mod  e.r  es.push(&#123; `        `test: /\.pug$/, `        `loader: &#39;pug-plain-loader&#39;, `        `options: &#123; `          `data: &#123; `            `title: &#39;My Website&#39;, `          `&#125;, `        `&#125;, `      `&#125;); `    `&#125;, `  `&#125;, &#125;; |
| :----------------------------------------------------------- |

在这个例子中，我们使用pug-plain-loader来处理.pug文件，并在options属性中指定了一些数据。在页面组件中，我们可以使用.pug文件来编写模板，例如：

| OpenGL Shading Language template `  `h1= title `  `p Welcome to my website! |
| :----------------------------------------------------------- |

在这个例子中，我们使用.pug文件来编写模板，并使用title变量来渲染页面标题。


&lt;a name=&quot;heading_325&quot;&gt;   Nodejs 

&lt;a name=&quot;heading_327&quot;&gt;  291.  什么是Node.js？它的特点是什么？ 

- Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，用于构建可扩展的网络应用程序。
- Node.js的特点包括非阻塞I/O模型、事件驱动、轻量高效、跨平台等。

&lt;a name=&quot;heading_328&quot;&gt;  292.  Node.js的事件驱动和非阻塞I/O模型是什么意思？ 

- 事件驱动：Node.js使用事件驱动的方式处理请求和响应。它基于事件循环机制，通过注册回调函数来处理异步操作的完成或错误。

- 非阻塞I/O模型：Node.js使用非阻塞I/O模型，意味着在进行I/O操作时，不会阻塞其他代码的执行。相反，它会继续执行后续的代码，当I/O操作完成时，通过回调函数来处理结果。

&lt;a name=&quot;heading_329&quot;&gt;  293.   Node.js中的事件循环是什么？它是如何工作的？ 

- 事件循环是Node.js的核心机制，用于处理异步操作和事件回调。

- 在事件循环中，Node.js会不断地检查事件队列，如果有事件需要处理，就会触发相应的回调函数进行处理。

- 当事件回调函数执行完毕后，事件循环会继续检查事件队列，处理下一个事件。

&lt;a name=&quot;heading_330&quot;&gt;  294.   什么是回调函数？为什么在Node.js中广泛使用回调函数？ 

- 回调函数是一种在异步编程中常用的技术，用于处理异步操作的结果或错误。

- 在Node.js中，由于非阻塞I/O模型和事件驱动的特性，回调函数被广泛使用来处理异步操作的完成或错误。

- 通过将回调函数作为参数传递给异步函数，可以在异步操作完成后执行相应的逻辑。

&lt;a name=&quot;heading_331&quot;&gt;  295.  Node.js中的模块是什么？如何创建和使用模块？ 

commonjs规范

基本原理： nodejs会把你项目中的js文件，在内部去进行包裹。

 ```javascript //  (function(mod  e, require) &#123; `    `// index.js `    `const myFunction = () =&gt; &#123; `      `console.log(&#39;Hello, World!&#39;); `    `&#125;;      `    `mod  e.exports = myFunction; &#125;)() |
| :----------------------------------------------------------- |

- 模块是Node.js中用于组织和复用代码的基本单位。

- 您可以使用mod  e.exports将代码导出为模块，然后使用require函数来引入模块。

- 例如，创建一个名为myMod  e.js的模块：

| JavaScript // myMod  e.js const myFunction = () =&gt; &#123; `  `console.log(&#39;Hello, World!&#39;); &#125;;  mod  e.exports = myFunction; |
| :----------------------------------------------------------- |

然后，在另一个文件中引入该模块：

| JavaScript // index.js const myMod  e = require(&#39;./myMod  e&#39;);  myMod  e(); // 输出：Hello, World! |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_332&quot;&gt;  296.  什么是包管理器？Node.js中最常用的包管理器是什么？ 

- 包管理器是用于管理和安装软件包（包括库、框架、工具等）的工具。

- 在Node.js中，最常用的包管理器是npm（Node Package Manager）。

- npm允许您在项目中安装、更新和删除依赖项，以及发布和共享自己的软件包。

&lt;a name=&quot;heading_333&quot;&gt;  297.  如何处理Node.js中的异步错误？有哪些常见的错误处理模式？ 

- 在Node.js中，可以使用回调函数的错误优先约定（Error-First Callback）来处理异步错误。

- 根据错误优先约定，回调函数的第一个参数用于传递错误对象（如果有错误），后续参数用于传递结果。

- 常见的错误处理模式包括使用if-else语句检查错误、使用try-catch块捕获错误、使用Promise进行错误处理等。

&lt;a name=&quot;heading_334&quot;&gt;  298.  Node.js中的流是什么？如何使用流来处理大型数据？ 

- 流是一种用于处理大型数据集的抽象概念，它允许以逐块的方式读取和写入数据。

- 在Node.js中，可以使用流来处理文件、网络请求、压缩和解压缩等操作。

- 通过使用流，可以减少内存占用，提高性能，并允许逐块处理数据而不必等待整个数据集加载完毕。

&lt;a name=&quot;heading_335&quot;&gt;  299.  什么是中间件？如何在Node.js中使用中间件？ 

- 中间件是在请求和响应之间执行的函数，用于处理HTTP请求和响应。

- 在Node.js中，可以使用Express.js等Web框架来使用中间件。

- 中间件可以用于处理身份验证、日志记录、错误处理等任务，以及在请求处理过程中执行其他自定义逻辑。

&lt;a name=&quot;heading_336&quot;&gt;  300.  如何在Node.js中处理文件操作？有哪些常见的文件操作方法？ 

`    `- 在Node.js中，可以使用fs模块来进行文件操作。

`    `- 常见的文件操作方法包括读取文件、写入文件、复制文件、重命名文件、删除文件等。

`    `- 例如，使用fs.readFile方法读取文件：

 ```javascript `      `const fs = require(&#39;fs&#39;);  `      `fs.readFile(&#39;file.txt&#39;, &#39;utf8&#39;, (err, data) =&gt; &#123; `        `if (err) &#123; `          `console.error(err); `          `return; `        `&#125; `        `console.log(data); `      `&#125;); |
| :----------------------------------------------------------- |

 

&lt;a name=&quot;heading_337&quot;&gt;  301.  Node.js中的缓冲区是什么？如何使用缓冲区处理二进制数据？ 

`    `- 缓冲区是用于处理二进制数据的临时存储区域。

`    `- 在Node.js中，可以使用Buffer类来创建和操作缓冲区。

`    `- 通过使用缓冲区，可以处理文件读取、网络通信、加密解密等操作中的二进制数据。

&lt;a name=&quot;heading_338&quot;&gt;  302.  如何在Node.js中进行调试和性能优化？ 

`    `- 在Node.js中，可以使用内置的调试器和性能分析工具来进行调试和性能优化。

`    `- 调试器：可以使用node inspect命令启动调试器，并使用Chrome开发者工具进行调试。

`    `- 性能分析：可以使用node --prof命令生成性能分析文件，并使用node --prof-process命令分析性能数据。

`    `- alinode 阿里

&lt;a name=&quot;heading_339&quot;&gt;  303.  nodejs事件循环机制（30K） 

Node.js的事件循环机制是其核心特性之一，它使得Node.js能够处理异步操作和事件驱动的编程模型。下面是Node.js事件循环的简要解释：

1. Node.js的事件循环是基于单线程的，但通过使用非阻塞I/O操作和事件驱动的方式，实现了高并发和高性能的处理能力。
2. 事件循环由以下几个主要组件（步骤）组成：

- 事件队列（Event Queue）：用于存储待处理的事件和回调函数。
- 观察者（Observers）：负责监视事件队列中的事件，并将其分发给相应的回调函数。
- I/O观察者（I/O Observers）：用于处理异步I/O操作的回调函数。
- 定时器观察者（Timer Observers）：用于处理定时器相关的回调函数。

3. 在事件循环的每个循环中，Node.js会执行以下几个步骤：

- 检查事件队列是否为空，如果为空则等待新的事件进入队列。
- 如果事件队列不为空，则从队列中取出一个事件，并将其分发给相应的回调函数进行处理。
- 执行回调函数，处理事件相关的逻辑。
- 检查是否有新的事件进入队列，如果有则继续下一次循环。

4. 在事件循环中，异步操作的回调函数会被添加到事件队列中，而不会立即执行。当事件循环执行到相应的回调函数时，才会被调用。

5. Node.js使用libuv库来实现事件循环机制，并提供了一些API来处理异步操作，如文件读写、网络请求等。

 总结来说，Node.js的事件循环机制通过单线程和非阻塞I/O操作，实现了高性能和高并发的处理能力。它允许开发者编写异步的、非阻塞的代码，提高了应用程序的响应能力和吞吐量。

 node的事件循环和浏览器不一样，你千万不要讲宏任务、微任务。

 &lt;a name=&quot;heading_340&quot;&gt;  304.  Buffer的作用？ 

 二进制处理

 &lt;a name=&quot;heading_341&quot;&gt;  305.  nodejs怎么充分利用CPU的能力？ 

6. 开启多进程，充分利用cpu多核

7. child\_process

8. Cluster

9. 进程和线程的区别，一个进程可以包含多个线程，线程是cpu的最小执行单元

 &lt;a name=&quot;heading_342&quot;&gt;  306.  node有哪些开启多线程的方式？ 

10. child\_process

11. Cluster

12. nodejs集群

13. 并发

14. 负载均衡

&lt;a name=&quot;heading_343&quot;&gt;  307.  child\_process和cluster是什么区别？ 

1. 功能：

- child\_process模块用于创建和控制子进程，可以通过它在Node.js中执行外部命令或脚本，并与子进程进行通信。
- cluster模块用于创建多个工作进程，以实现负载均衡和高可用性。每个工作进程都是一个独立的Node.js进程，可以处理客户端请求。

2\. 使用场景：

- child\_process适用于需要在Node.js中执行外部命令或脚本的场景，例如调用系统命令、执行Shell脚本、处理文件操作等。

- cluster适用于需要处理并发请求的场景，例如Web服务器、API服务器等。通过创建多个工作进程，可以利用多核CPU的优势，提高应用程序的性能和可扩展性。

3\. 进程通信：

- child\_process模块提供了多种进程间通信的方式，如标准输入输出、事件、消息传递等。可以通过这些方式在父进程和子进程之间进行数据交换和通信。

- cluster模块使用内置的IPC（Inter-Process Communication）通道，在主进程和工作进程之间进行通信。可以通过IPC通道发送消息和共享数据。

4\. 编程模型：

- child\_process模块是基于回调函数的异步编程模型，可以通过回调函数处理子进程的输出和错误。

- cluster模块是基于事件的编程模型，可以通过监听事件来处理工作进程的启动、退出和消息。

总结来说，child\_process模块用于创建和控制子进程，适用于执行外部命令和脚本的场景，而cluster模块用于创建多个工作进程，适用于处理并发请求的场景。它们在功能、使用场景、进程通信和编程模型等方面有所不同。

&lt;a name=&quot;heading_344&quot;&gt;  308.  crpto这个包有什么作用？ 

进行加密的包

&lt;a name=&quot;heading_345&quot;&gt;  309.  nodejs中有几种类型的定时器？ 

` `settimeout

setInterval

setImmediate (有点像浏览器的微任务，有性能问题，一般不建议用这个)

&lt;a name=&quot;heading_346&quot;&gt;  310.  nodejs一般怎么部署上线？ 

1. 单机适合 PM2 （适合中小项目自己玩，用户量不大）

2. 集群，大型应用   云平台  K8S容器编排

 &lt;a name=&quot;heading_347&quot;&gt;  311.  PM2的应用场景和功能 

3. 进程管理：PM2可以启动、停止、重启和删除Node.js应用程序进程。它可以管理多个应用程序，并确保它们在服务器上持续运行。

 2\. 自动重启：如果应用程序崩溃或发生异常退出，PM2可以自动重启它，以确保应用程序的高可用性。

 3\. 负载均衡：PM2支持负载均衡，可以将请求分发给多个应用程序实例，以提高应用程序的性能和可扩展性。

 4\. 日志管理：PM2可以收集和管理应用程序的日志输出。它可以将日志输出到控制台、文件或日志管理工具（如Elasticsearch、Logstash等）。

 5\. 监控和指标：PM2提供了监控和指标功能，可以实时监视应用程序的CPU使用率、内存使用率、请求响应时间等指标，并生成报告。

 6\. 环境变量管理：PM2可以管理应用程序的环境变量，可以在启动应用程序时设置环境变量，并在应用程序中访问这些变量。

 7\. 部署和更新：PM2可以帮助您部署和更新Node.js应用程序。它可以从代码仓库中拉取最新的代码，并自动构建和部署应用程序。

 总结来说，PM2是一个功能强大的进程管理器，可以帮助您管理和监控Node.js应用程序的运行。它提供了进程管理、自动重启、负载均衡、日志管理、监控和指标、环境变量管理以及部署和更新等功能。

 &lt;a name=&quot;heading_348&quot;&gt;   Electron 

 &lt;a name=&quot;heading_350&quot;&gt;  312.  什么是 Electron？  

 Electron 是一个开源的框架，用于使用 Web 技术构建跨平台桌面应用程序。它使用 Chromium 渲染引擎和 Node.js 运行时环境来实现这一目的。

 &lt;a name=&quot;heading_351&quot;&gt;  313.  Electron 的工作原理是什么？ 

 ` `Electron 的工作原理是将 Chromium 渲染引擎和 Node.js 运行时环境嵌入到桌面应用程序中，然后通过调用 Node.js API 来访问本地系统资源和功能。这使得开发者可以使用 Web 技术构建本地应用程序，而无需学习其他语言或框架。

 &lt;a name=&quot;heading_352&quot;&gt;  314.  如何创建一个 Electron 应用程序？ 

 ` `要创建一个 Electron 应用程序，需要使用 Node.js 和 npm 安装 Electron 的开发环境。然后，可以使用任何文本编辑器来编写应用程序代码，最后使用 Electron 的命令行工具来运行应用程序。

 &lt;a name=&quot;heading_353&quot;&gt;  315.  Electron 支持哪些操作系统？  

 Electron 支持 Windows、macOS 和 Linux 等主要操作系统。

 &lt;a name=&quot;heading_354&quot;&gt;  316.  Electron 如何处理跨平台问题？  

 Electron 使用 Node.js 和 Chromium 渲染引擎来实现跨平台功能。因此，开发者可以使用相同的代码库来构建 Windows、macOS 和 Linux 等不同的应用程序。

 &lt;a name=&quot;heading_355&quot;&gt;  317.  如何在 Electron 应用程序中调用本地系统资源和功能？  

 可以使用 Node.js API 来访问本地系统资源和功能，例如文件系统、进程、网络等。

 &lt;a name=&quot;heading_356&quot;&gt;  318.  如何理解IPC通信 

4. 在主进程中，使用ipcMain模块来监听和处理来自渲染进程的消息。可以在主进程的主文件（通常是main.js）中引入ipcMain模块。

```javascript const &#123; ipcMain &#125; = require(&#39;electron&#39;); |
 | :----------------------------------------------------- |

 2\. 在主进程中，使用ipcMain.on方法来监听特定的消息事件。可以在监听器函数中处理接收到的消息，并发送回复消息给渲染进程。

```javascript ipcMain.on(&#39;message-from-renderer&#39;, (event, data) =&gt; &#123; `  `// 处理接收到的消息 `  `console.log(data);  `  `// 发送回复消息给渲染进程 `  `event.reply(&#39;message-to-renderer&#39;, &#39;Hello from main process!&#39;); &#125;); |
 | :----------------------------------------------------------- |

 3\. 在渲染进程中，使用ipcRenderer模块来发送消息给主进程，并接收主进程的回复消息。可以在渲染进程的渲染文件（通常是renderer.js）中引入ipcRenderer模块。

```javascript const &#123; ipcRenderer &#125; = require(&#39;electron&#39;); |
 | :--------------------------------------------------------- |

 4\. 在渲染进程中，使用ipcRenderer.send方法发送消息给主进程，并通过ipcRenderer.on方法监听主进程的回复消息。

```javascript ipcRenderer.send(&#39;message-from-renderer&#39;, &#39;Hello from renderer process!&#39;);  ipcRenderer.on(&#39;message-to-renderer&#39;, (event, data) =&gt; &#123; `  `// 处理接收到的回复消息 `  `console.log(data); &#125;); |
 | :----------------------------------------------------------- |

 通过以上步骤，您可以在主进程和渲染进程之间进行双向的消息通信。主进程可以监听和处理来自渲染进程的消息，并发送回复消息给渲染进程。渲染进程可以发送消息给主进程，并接收主进程的回复消息。

 请注意，Electron的IPC通信是基于事件的，因此需要在主进程和渲染进程中分别设置监听器来处理消息和回复消息。

 &lt;a name=&quot;heading_357&quot;&gt;   微前端体系（乾坤等） 

 &lt;a name=&quot;heading_359&quot;&gt;  319.  微前端解决了什么问题 

5. 大型应用拆分：传统的单体前端应用程序往往随着业务的增长变得庞大而复杂。微前端通过将应用程序拆分为更小的、自治的子应用程序，使得团队可以独立开发、测试和部署这些子应用程序，从而简化了大型应用的开发和维护。

6. 技术栈多样性：在大型组织中，不同团队可能使用不同的技术栈来开发前端应用程序。微前端允许每个子应用程序使用自己喜欢的技术栈，例如React、Ang  ar、Vue等，从而提高了团队的开发效率和灵活性。

7. 独立部署和扩展：微前端使得每个子应用程序都可以独立部署和扩展。这意味着团队可以根据需要对特定的子应用程序进行更新和扩展，而无需重新部署整个应用程序。这样可以减少发布的风险，并提高应用程序的可用性和可扩展性。

8. 增量升级：在传统的单体前端应用程序中，升级整个应用程序可能会带来风险和复杂性。微前端允许团队逐步升级每个子应用程序，而不会影响其他部分的功能。这样可以降低升级的风险，并使团队能够更快地推出新功能和修复bug。

9. 独立团队协作：微前端使得不同团队可以独立开发和维护各自的子应用程序，而不会相互干扰。每个团队可以专注于自己的领域，并通过定义清晰的接口和通信机制来协调子应用程序之间的交互。这样可以提高团队的效率和协作能力。

 &lt;a name=&quot;heading_360&quot;&gt;  320.  乾坤和无界的区别是什么？ 

  共同点：  当路由切换的时候，可以去加载对应应用的代码，让其跑在容器里。

- 具备 加载和卸载子应用的能力 ，页面从一个子应用切换到另一个子应用时，能正常进行加载和渲染；

- 具有 路由状态保持能力 ，激活子应用后，浏览器刷新、前进、后退子应用的路由都可以正常工作；

- 主应用和子应用、子应用和子应用之间 可以相互进行通信 ；

- 每个微应用都 可独立仓库管理，独立技术栈开发、独立部署、独立运行 ；

 差异点：  容器实现方案不同，[乾坤](https://qiankun.umijs.org/)是基于single-spa方案，使用function + proxy + with实现，[无界](https://wujie-micro.github.io/doc/)是基于WebComponent + iframe来实现。

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.067.png)

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.068.png)

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.069.png)

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.070.png)

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.071.png)

&lt;a name=&quot;heading_361&quot;&gt;  321.  iframe做微前端有什么缺点 

性能问题：使用iframe会引入额外的性能开销。每个iframe都需要加载和渲染独立的HTML文档，并且在不同的iframe之间进行通信也需要额外的开销。这可能会导致整体应用程序的性能下降。

安全性问题：由于iframe可以加载来自不同域的内容，因此可能存在安全风险。恶意代码可能会通过iframe访问和篡改主应用程序的内容，从而导致安全漏洞。

跨域通信问题：在使用iframe进行微前端时，不同iframe之间的通信可能会受到同源策略的限制。跨域通信需要使用特定的技术，如postMessage，来进行安全的跨域消息传递。

共享状态和数据共享问题：由于每个iframe都是独立的文档环境，共享状态和数据共享可能会变得复杂。在不同的iframe之间传递和同步状态需要额外的工作，可能需要使用特定的技术或工具来解决这个问题。

调试和开发体验问题：使用iframe进行微前端可能会增加调试和开发的复杂性。每个iframe都是独立的文档环境，可能需要单独调试和开发每个子应用程序，这可能会增加开发人员的工作量和调试难度。

&lt;a name=&quot;heading_362&quot;&gt;  322.  乾坤和无界该怎么选择 

推荐无界，更轻量，业务侵入性更小。

&lt;a name=&quot;heading_363&quot;&gt;   H5移动端 

&lt;a name=&quot;heading_365&quot;&gt;  323.  移动端一般是怎么进行适配的 

&lt;a name=&quot;heading_366&quot;&gt;  324.  移动端是怎么通信的 

&lt;a name=&quot;heading_367&quot;&gt;  325.  移动端怎么进行技术选型 

&lt;a name=&quot;heading_368&quot;&gt;  326.  移动端项目有哪些要注意的问题 

&lt;a name=&quot;heading_369&quot;&gt;   Threejs 

&lt;a name=&quot;heading_371&quot;&gt;  327.  什么是three.js？ 

Three.js是一个基于JavaScript的3D库，它简化了WebGL的复杂性，使得开发人员可以更轻松地创建和呈现3D图形。

&lt;a name=&quot;heading_372&quot;&gt;  328.  three.js的主要特点是什么？ 

答案：Three.js的主要特点是易于使用、灵活性和高性能。它提供了许多实用的功能和工具，如场景管理、光照、材质和动画等，同时也支持自定义着色器和自定义缓冲区。

&lt;a name=&quot;heading_373&quot;&gt;  329.  three.js中如何创建一个简单的3D场景？ 

创建一个简单的Three.js场景需要以下步骤：首先创建一个场景对象，然后创建一个相机对象，接着创建一个渲染器对象，并将场景和相机对象传递给渲染器。最后，通过渲染循环来更新场景和渲染图像。

&lt;a name=&quot;heading_374&quot;&gt;  330.  在three.js中，如何使用材质和纹理来改变物体的外观？ 

在Three.js中，可以使用不同的材质和纹理来改变物体的外观。例如，使用MeshLambertMaterial可以应用一种基本的材质，使用MeshPhongMaterial可以应用一种更高级的材质，使用MeshStandardMaterial可以应用一种更接近现实的材质。纹理可以通过将图像文件加载到TextureLoader中来应用。

&lt;a name=&quot;heading_375&quot;&gt;  331.  three.js中的着色器是什么？如何创建和使用自定义着色器？ 

Three.js中的着色器是用来处理3D模型表面的渲染效果的程序。它们通常用于实现复杂的视觉效果，如阴影、光照、纹理等。可以通过创建ShaderMaterial或RawShaderMaterial来使用自定义着色器。在着色器代码中，可以通过&quot;THREE.uniforms&quot;来传递uniform变量，通过&quot;THREE.vertexShader&quot;和&quot;THREE.fragmentShader&quot;来定义顶点和片段着色器。

&lt;a name=&quot;heading_376&quot;&gt;  332.  什么是缓冲区？在three.js中如何使用缓冲区？ 

缓冲区是用于存储和管理数据的一种内存区域。在Three.js中，可以通过BufferGeometry来创建自定义的缓冲区，以实现更高效的渲染。例如，可以通过BufferGeometry来直接操作顶点数据、索引数据和材质数据等。

&lt;a name=&quot;heading_377&quot;&gt;  333.  如何优化three.js的渲染性能？ 

优化Three.js的渲染性能可以通过以下方法实现：减少绘制调用次数、使用贴图合并、减少着色器切换、优化几何体、使用视锥体裁剪等。此外，还可以通过使用Web Workers来将计算密集型任务移至后台线程，避免阻塞主线程。

334.  three.js中的相机有哪些类型？它们的特点是什么？ 

Three.js中的相机类型有PerspectiveCamera（透视相机）和OrthographicCamera（正交相机）。透视相机模拟人眼的视角效果，近大远小，适合表现三维空间感。正交相机则没有透视效果，适合表现二维画面效果或者创造一些特殊视觉效果。

&lt;a name=&quot;heading_379&quot;&gt;  335.  如何使用three.js来处理用户的交互事件？ 

可以使用Three.js提供的EventDispatcher对象来处理用户的交互事件。可以通过调用EventDispatcher的addEventListener()方法来监听特定事件，并在事件触发时执行相应的回调函数。例如，可以监听&quot;mousemove&quot;事件来捕捉鼠标移动，或者监听&quot;keydown&quot;事件来捕捉键盘输入等。

&lt;a name=&quot;heading_380&quot;&gt;  336.  three.js中的动画有哪些类型？如何创建动画？ 

Three.js中的动画类型有基于时间的动画（如动画曲线和时间轴），基于物理的动画（如刚体动力学和碰撞检测），以及基于着色器的动画（如顶点着色器和片元着色器）。可以通过Three.js提供的AnimationMixer和AnimationAction来创建动画。首先需要创建一个AnimationAction对象，然后将其与物体关联起来，最后通过AnimationMixer来控制动画的播放和时间轴的推进等。

&lt;a name=&quot;heading_381&quot;&gt;  337.  如何将three.js与WebGL结合使用？ 

答案：Three.js基于WebGL构建，因此它与WebGL紧密集成。可以通过创建WebGLRenderer对象来启用WebGL渲染。此外，可以通过使用Three.js提供的各种实用工具和功能来简化WebGL的使用，如场景管理、光照、材质和动画等。

338.  three.js中有哪些常见的错误和问题？如何解决它们？ 

答案：Three.js中常见的错误和问题包括内存泄漏、渲染效率低下、着色器错误等。解决这些问题的方法包括合理管理内存、优化渲染流程、正确编写着色器代码等。此外，Three.js社区提供了许多资源和支持，可以通过查阅文档、参与论坛和寻求帮助来解决问题。

339.  如何使用three.js来创建复杂的3D模型和场景？ 

答案：创建复杂的3D模型和场景需要使用Three.js提供的各种高级功能和技术。可以通过加载外部3D模型文件来创建复杂的模型，如.obj或.fbx文件。可以使用Three.js提供的各种几何体工具来构建自定义模型。对于复杂的场景，可以通过管理多个场景对象、使用光源和阴影、应用材质和纹理等来实现。

340.  three.js在实时渲染方面有哪些应用？ 

答案：Three.js在实时渲染方面有许多应用，包括游戏、虚拟现实、增强现实、可视化数据等。通过使用Three.js的实时渲染功能，可以在网页浏览器中实现流畅的3D图形呈现。

341.  three.js在游戏开发中有哪些应用？ 

答案：Three.js在游戏开发中有广泛的应用。可以使用Three.js来创建3D游戏场景、角色、道具等。通过结合游戏引擎和Three.js，可以实现丰富的3D游戏效果。

342.  three.js在虚拟现实和增强现实中有哪些应用？ 

答案：Three.js在虚拟现实（VR）和增强现实（AR）中也有广泛的应用。可以使用Three.js来创建VR或AR场景，通过头戴式显示器或其他设备呈现3D图形。也可以将Three.js与AR库结合使用，实现增强现实的视觉效果。

#    小程序 

##  343.  请谈谈微信小程序主要目录和文件的作用？ 

1. project.config.json：项目配置文件，用的最多的就是配置是否开启https校验

2. App.js：设置一些全局的基础数据等
3. App.json：底部tab，标题栏和路由等设置
4. App.wxss：公共样式，引入iconfont等
5. pages：里面包含一个个具体的页面
6. index.json：配置当前页面标题和引入组件
7. index.wxml：页面结构
8. index.wxss：页面样式表
9. index.js：页面的逻辑，请求和数据处理

344. ## 请谈谈wxml与标准的html的异同？

都是用来描述页面的结构
都由标签，属性等构成
标签名字不一样，且小程序标签更少，单一标签更多
多了一些 wx:if 这样的属性以及&#123;&#123;&#125;&#125; 这样的表达式
WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览
组件封装不同，WXML对组件进行了重新封装
小程序运行在JS Core内，没有DOM树和windiw对象，小程序中无法使用window对象和document对象。

345.  请谈谈WXSS和CSS的异同？ 

1. 都是用来描述页面的样子

2. WXSS具有CSS大部分的特性，也做了一些扩充和修改

3. WXSS新增了尺寸单位，WXSS在底层支持新的尺寸单位rpx

4. WXSS仅支持部分CSS选择器

5. WXSS提供全局样式与局部样式

346. ## 你是怎么封装微信小程序的数据请求的？

在根目录下创建util目录及api.js文件和apiConfig.js文件
在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等
在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出
在具体的页面中导入
或
将所有的接口放在统一的js文件中并导出
在app.js中创建封装请求数据的方法
在子页面中调用封装的请求数据

&lt;a name=&quot;heading_393&quot;&gt;  347.  小程序页面之间有哪些（传值）传递数据的方法？ 

使用全局遍历实现数据传递
页面跳转或重定向时，使用url带参数传递数据
使用组件模板 template传递参数
使用缓存传递参数
使用数据库传递参数
或
给html元素添加data-\*属性来传递值，然后通过e.currentTarget.dataset或onload的param参数获取（data- 名称不能有大写字母，不可以存放对象）
设置id 的方法标识来传值，通过e.currentTarget.id获取设置的id值，然后通过设置全局对象的方式来传递数据
在navigator中添加参数数值

&lt;a name=&quot;heading_394&quot;&gt;  348.  请谈谈小程序的双向绑定和vue的异同？ 

大体相同，但小程序之间this.data的属性是不可以同步到视图的，必须调用this.setData()方法

&lt;a name=&quot;heading_395&quot;&gt;  349.  请谈谈小程序的生命周期函数 

onLoad()页面加载时触发，只会调用一次，可获取当前页面路径中的参数
onShow()页面显示/切入前台时候触发，一般用来发送数据请求
onReady()页面初次渲染完成时触发，只会调用一次，代表页面已可和视图层进行交互
onHide()页面隐藏/切入后台时触发，如底部tab切换到其他页面或小程序切入后台等
onUnload()页面卸载时触发，如redirectTO或navigateBack到其他页面时

&lt;a name=&quot;heading_396&quot;&gt;  350.  简述微信小程序原理 

小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；
它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现；
它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发；
功能可分为webview和APPService两个部分，webview主要用来展示UI，appservice用来处理业务逻辑，数据及接口调用，它们在两个进程中进行，通过系统层JSBridge实现通信，实现UI的渲染，事件处理；
webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；
两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。
javaScript的代码是运行在微信App中的，因此一些h5技术的应用需要微信APP提供对应的API支持
wxml 微信自己基于xml语法开发的，因此在开发时只能使用微信提供的现有标签，html的标签是无法使用的
wxss具有css的大部分特性，但并不是所有都支持，没有详细文档（wxss的图片引入需要使用外链地址，没有body，样式可以使用import导入）

&lt;a name=&quot;heading_397&quot;&gt;  351.  请谈谈原生开发小程序，wepy，mpvue的对比？ 

个人认为，如果是新项目，且没有旧的 h5 项目迁移，则考虑用小程序原生开发，好处是相比于第三方框架，坑少。
而如果有 老的 h5 项目是 vue 开发 或者 也有 h5 项目也需要小程序开发，则比较适合 wepy 或者 mpvue 来做迁移或者开发，近期看wepy几乎不更新了，所以推荐美团的mpvue。
而如果如果团队前端强大，自己做一套框架也没问题。

&lt;a name=&quot;heading_398&quot;&gt;  352.  简单描述下微信小程序的 相关文件类型 

1\.wxml 模板文件，是框架设计的一套标签预言，结合基础组件，事件系统，可以构建出页面的结构
wxss 样式文件，是一套样式语言，用于描述WXML的组件样式
js脚本逻辑文件。逻辑处理网络请求
json配置文件，小程序设置，如页面注册，页面标题及tabBar
2\.app.json 整个小程序的全局配置，包括：

pages:[所有页面路径]

网络设置（网络超时事件）

页面表现（页面注册）

window：（背景色，导航样式，默认标题）

底部tab等

3\.app.js 监听并处理小程序的生命周期函数，声明全局变量

4\.app.wxss 全局配置的样式文件

&lt;a name=&quot;heading_399&quot;&gt;  353.  那些方法来提高微信小程序的应用速度？ 

6. 提高页面的加载速度

7. 用户行为预测

8. 减少默认的data的大小

9. 组件化方案

&lt;a name=&quot;heading_400&quot;&gt;  354.  分析微信小程序的优劣势？ 

优势：

容易上手，基础组件库比较全，基本不需要考虑兼容问题
开发文档比较完善，开发社区比较活跃，支持插件式开发
良好的用户体验，无需下载，通过搜索和扫一扫就可以打开，打开速度快，安卓上可以添加到桌面，与原生APP差不多
开发成本比APP要低
为用户提供良好的保障（小程序发布，严格是审查流程）


劣势：
限制较多，页面大小不能超过1M，不能打开超过5个层级的页面
样式单一，部分组件已经是成型的，样式不可修改，例如：幻灯片，导航
推广面窄，不能分享朋友圈，只能通过分享给朋友，附加小程序推广
依托与微信，无法开发后台管理功能
后台调试麻烦，因为api接口必须https请求且公网地址
真机测试，个别安卓和苹果表现迥异，例如安卓的定位功能加载很慢

&lt;a name=&quot;heading_401&quot;&gt;  355.  微信小程序和H5的区别？ 

- 运行环境不同（小程序在微信运行，h5在浏览器运行）

- 开发成本不同（h5需要兼容不同的浏览器）

- 获取系统权限不同（系统级权限可以和小程序无缝衔接）

- 应用在生成环境的运行速度流程（h5需不断对项目优化来提高用户体验）

&lt;a name=&quot;heading_402&quot;&gt;  356.  怎么解决微信小程序的异步请求问题？ 

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.072.png)

&lt;a name=&quot;heading_403&quot;&gt;  357.  小程序关联微信公众号如何确定用户的唯一性？ 

使用wx.getUserlnfo方法 [withCredentials](https://so.csdn.net/so/search?q=withCredentials&amp;spm=1001.2101.3001.7020)为true时，可获取encryptedData，里面有union\_id，后端需要进行对称解密

&lt;a name=&quot;heading_404&quot;&gt;  358.  使用webview直接加载要注意那些事项？ 

- 必须要在小程序后台使用管理员添加业务域名

- h5页面跳转至小程序的脚步必须是1.3.1以上

- 微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上

- h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的

&lt;a name=&quot;heading_405&quot;&gt;  359.  小程序调用后台接口遇到那些问题？ 

数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序
小程序不可以直接渲染文章内容这类型的html文本，显示需要借助插件


注：插件渲染会导致页面加载变慢，建议在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签，然后其他的标签让插件来做

&lt;a name=&quot;heading_406&quot;&gt;  360.  微信小程序如何实现下拉刷新？ 

用view代替scroll-view，设置onP  lDownRefresh函数实现

&lt;a name=&quot;heading_407&quot;&gt;  361.  webview中的页面怎么跳转回小程序? 

![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.073.png)

&lt;a name=&quot;heading_408&quot;&gt;  362.  bindtap和catchtap的区别？ 

- bind事件绑定不会阻止冒泡事件向上冒泡

- catch事件绑定可以阻止冒泡事件向上冒泡

&lt;a name=&quot;heading_409&quot;&gt;  363.  简述wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？ 

- 在wxml页面中：跳转新页面，在当前页打开，切换到首页Tab

- 在js页面中：分为应用内的页面，和tabBar页面

- 如果上述跳转遇到跳转失败或者无效的问题，请访问：wx.navigateTo/wx.redirectTo无效

&lt;a name=&quot;heading_410&quot;&gt;  364.  小程序和Vue写法的区别？ 

遍历的时候：小程序wx:for=&quot;list&quot;,而Vue是v-for=&quot;item in list&quot;
调用data模型（赋值）的时候：

小程序：this.data.item // 调用，this.setDate(&#123;item:1&#125;)//赋值

Vue：this.item //调用，this.item=1 //赋值

&lt;a name=&quot;heading_411&quot;&gt;  365.  小程序与原生App那个好？ 

各有各自的优点，都又有缺点

小程序的优点：

基于微信平台开发，享受微信自带的流量，这个优点最大
无需安装，只要打开微信就能用，不占手机内存，体验好
开发周期段，一般最多一个月就可以上线完成
开发所需的资金少，所需资金是开发原生APP的一半不到
小程序名称是唯一的，在微信的搜索里权重很高
容易上手，只要之前有HTML+CSS+JS基础知识，写小程序基本没有大问题
基本不需要考虑兼容性问题，只要微信可以正常运行的机器，就可以运行小程序
发布，审核高效，基本上午发布审核，下午就审核通过，升级简单，支持灰度发布
开发文档完善，社区活跃
支持插件式开发，一些基本功能可以开发成插件，供多个小程序使用
缺点：

局限性很强（比如页面大小不能超过1M，不能打开超过5个层级的页面，样式单一，小程序的部分组件已经是成型的了，样式不能修改，比如幻灯片，导航）只能依赖于微信依托与微信，无法开发后台管理功能
不利于推广，推广面窄，不能分享朋友圈，只能分享给朋友，附近小程序推广，其中附加小程序也收到微信限制
后台调试麻烦，因为API接口必须https请求，且公网地址，也就是说后台代码必须发布到远程服务器上；当然我们可以修改host进行dns映射把远程服务器转到本地，或者开启tomcat远程调试；不管怎么说终归调试比较麻烦
前台测试有诸多坑，最头疼莫过于模拟器与真机显示不一致
js引用只能使用绝对路径，不能操作DOM
原生App优点：

原生的相应速度快
对于有无网络操作时，譬如离线操作基本选用原生开发
需要调用系统硬件的功能（摄像头，拨号，短信蓝牙..）
在无网络或者弱网情况下体验好
原生App缺点：

开发周期长，开发成本高，需要下载

&lt;a name=&quot;heading_412&quot;&gt;  366.  小程序的发布流程（开发流程） 

1. 注册微信小程序账号

2. 获取微信小程序的AppID

3. 下载微信小程序开发者工具

4. 创建demo项目

5. 去微信公众号配置域名

6. 手机浏览

7. 代码上传

8. 提交审核

9. 小程序发布

 &lt;a name=&quot;heading_413&quot;&gt;  367.  webview中的页面怎么跳回小程序中？ 

 首先，需要在你的html页面中引用一个js文件

 ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.074.png)

 &lt;a name=&quot;heading_414&quot;&gt;  368.  小程序授权登录流程 

 授权，微信登录获取code，微信登录，获取 iv , encryptedData 传到服务器后台，如果没有注册，需要注册。

 &lt;a name=&quot;heading_415&quot;&gt;  369.  小程序支付如何实现？ 

10. 小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限

11. 绑定商户号

12. 在小程序填写合法域

13. 调用wx.login()获取appid

  ![](D:/Notes/Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.075.png)

  &lt;a name=&quot;heading_416&quot;&gt;  370.  小程序还有那些功能？ 

  客服功能，录音，视频，音频，地图，定位，拍照，动画，canvas

  &lt;a name=&quot;heading_417&quot;&gt;   Taro 

  &lt;a name=&quot;heading_419&quot;&gt;  371.  什么是taro 

  Taro是一个多端开发框架，可以使用一套代码编写跨平台的小程序、H5和React Native应用。它的作用是简化跨平台开发的复杂性，提高开发效率。

  &lt;a name=&quot;heading_420&quot;&gt;  372.  taro有什么特点 

  Taro是一个多端开发框架，可以使用一套代码编写跨平台的小程序、H5和React Native应用。它的作用是简化跨平台开发的复杂性，提高开发效率。

  &lt;a name=&quot;heading_421&quot;&gt;  373.  如何在taro中创建一个页面 

 ```javascript taro create --name MyPage |
  | :-------------------------------------- |

  &lt;a name=&quot;heading_422&quot;&gt;  374.  如何在taro中进行路由导航 

 ```javascript import Taro from &#39;@tarojs/taro&#39; import &#123; navigateTo &#125; from &#39;@tarojs/taro-router&#39;  // 导航到指定页面 navigateTo(&#123; `  `url: &#39;/pages/otherPage&#39; &#125;) |
  | :----------------------------------------------------------- |

  &lt;a name=&quot;heading_423&quot;&gt;  375.  如何taro中进行网络请求 

 ```javascript import Taro from &#39;@tarojs/taro&#39; import &#123; navigateTo &#125; from &#39;@tarojs/taro-router&#39;  // 导航到指定页面 navigateTo(&#123; `  `url: &#39;/pages/otherPage&#39; &#125;) |
  | :----------------------------------------------------------- |

  &lt;a name=&quot;heading_424&quot;&gt;  376.  taro可以使用状态管理工具吗？ 

  可以，redux、vuex都可以使用的

  &lt;a name=&quot;heading_425&quot;&gt;  377.  taro怎么写样式？ 

 ```javascript import Taro from &#39;@tarojs/taro&#39; import &#123; View &#125; from &#39;@tarojs/components&#39;  function MyComponent() &#123; `  `return ( `    `&lt;View className=&quot;container&quot;&gt; `      `&lt;View className=&quot;content&quot;&gt;Hello, Taro!&lt;/View&gt; `    `&lt;/View&gt; `  `) &#125; |
  | :----------------------------------------------------------- |

  &lt;a name=&quot;heading_426&quot;&gt;  378.  taro的原理是什么？ 

14. 统一语法：Taro提供了一套统一的语法规范，开发者可以使用类似于React的组件化开发模式，编写可复用的组件和页面。这样，开发者可以在不同的平台上使用相同的语法进行开发，减少了学习成本和开发难度。

15. 跨平台编译：Taro的编译器会将开发者编写的代码转换为不同平台的代码。例如，对于小程序平台，Taro会将代码转换为微信小程序、支付宝小程序等平台所支持的代码；对于H5平台，Taro会将代码转换为符合浏览器标准的代码；对于React Native平台，Taro会将代码转换为React Native所支持的代码。这样，开发者只需要编写一次代码，就可以在不同平台上运行。

16. 平台差异处理：Taro会根据不同平台的特性和限制，对代码进行相应的处理和适配。例如，对于小程序平台，Taro会处理小程序的生命周期、事件系统、组件渲染等方面的差异；对于H5平台，Taro会处理浏览器的DOM操作、事件处理等方面的差异。这样，开发者可以在不同平台上获得一致的开发体验。

17. 插件生态系统：Taro提供了丰富的插件生态系统，开发者可以通过插件扩展Taro的功能。这些插件可以提供一些特定平台的功能支持、性能优化、开发工具等。开发者可以根据自己的需求选择和使用这些插件，以满足特定平台的需求。

  &lt;a name=&quot;heading_427&quot;&gt;  379.  taro解决了什么问题 

  Taro解决了跨平台开发的问题。在移动应用开发中，不同平台（如小程序、H5、React Native等）有不同的开发语言、开发工具和API，开发者需要为每个平台编写不同的代码。这导致了开发成本的增加、开发周期的延长和代码复用的困难。

  Taro通过提供一套统一的语法和组件库，使开发者可以使用一套代码编写跨平台的应用。开发者只需编写一次代码，然后通过Taro的编译器将代码转换为不同平台所支持的代码。这样，开发者可以在不同平台上获得一致的开发体验，并且可以更高效地开发和维护应用。

  Taro还解决了平台差异的问题。不同平台有不同的特性和限制，开发者需要针对每个平台进行适配和处理。Taro会根据不同平台的特性和限制，对代码进行相应的处理和适配，使开发者可以在不同平台上获得一致的功能和用户体验。

  此外，Taro还提供了丰富的插件生态系统，开发者可以根据自己的需求选择和使用插件，以满足特定平台的需求，进一步提高开发效率和应用性能。

  &lt;a name=&quot;heading_428&quot;&gt;  380.  taro适合什么样的项目 

  Taro适合用于开发跨平台的移动应用项目，特别是小程序、H5和React Native应用。以下是一些适合使用Taro的项目类型：

18. 小程序应用：Taro最初是为了解决小程序开发的问题而创建的，因此非常适合用于开发各种类型的小程序应用，如微信小程序、支付宝小程序、百度小程序等。

19. 跨平台应用：如果您需要开发同时支持小程序、H5和React Native的应用，Taro是一个很好的选择。通过使用Taro，您可以使用一套代码编写跨平台的应用，减少开发成本和维护工作。

20. 多端应用：如果您需要开发适用于多个移动平台的应用，Taro可以帮助您实现一套代码多端运行。您可以使用Taro编写一次代码，然后通过Taro的编译器将代码转换为不同平台所支持的代码。

21. 快速原型开发：Taro提供了丰富的组件库和开发工具，可以帮助您快速构建原型应用。您可以使用Taro进行快速迭代和验证想法，以便更快地推出产品。

  &lt;a name=&quot;heading_429&quot;&gt;   UniApp 

  &lt;a name=&quot;heading_431&quot;&gt;  381.  谈谈你对uni-app的理解 

  uni-app是一个使用Vue.js开发所有前端应用的框架，开发者编写一套代码，可以发布到IOS、Android、Web（响应式）、以及各种小程序、快应用等多个平台。

  uniapp真正做到 一套代码多端发行 ， 支持原生代码混写和原生sdk集成 。

  运行体验更好。组件、api与微信小程序一致，兼容 Weex 原生渲染。

  通用技术栈，学习成本更低。Vue的语法，微信小程序的api，对于前端开发人员来说更容易上手。

  开放生态，组件更丰富。支持通过npm安装第三方包；支持微信小程序自定义组件及sdk；兼容 mpvue 组件及项目；app端支持与原生混合编码；

  &lt;a name=&quot;heading_432&quot;&gt;  382.  uni中如何为不同的平台设置不同的代码 

  通过 条件注释 来为不同平台设置不同的代码：

  条件注释的作用： 实现跨端兼容 

  使用方法：以  #ifdef  或  #ifndef  加平台代值开头，以  #endif  结尾

  #ifdef：if defined 如果是xx平台则运行代码块 #ifndef：if not defined 如果不是xx平台才运行代码块

- H5        H5

- MP-WEIXIN        微信小程序

- APP-PLUS  app

- MP  所有小程序

&lt;a name=&quot;heading_433&quot;&gt;   3.uni支持的文件类型 

- .vue

- .js

- .css

- pages.json

- 各预编译语言文件，如：.scss、.less、.stylus、.ts、.pug

&lt;a name=&quot;heading_434&quot;&gt;  383.  uniapp中封装接口请求相较于微信小程序有什么要注意的 

uniapp和微信小程序都提供了网络请求API（uni.request(OBJECT) 和 wx.request(object)），但 uniapp 为了实现跨端兼容，需要注意网络请求 跨域问题 ，微信小程序不用考虑多端兼容，也不会出现跨域问题。

uniapp中的跨域问题依然可以通过在  vue.config.js  中配置 Proxy代理 解决；

devServer ——&gt; proxy ——&gt; changeOrigin: true,  //是否跨域

&lt;a name=&quot;heading_435&quot;&gt;  384.  uni-app 在非h5端上运行为什么要在架构上分为逻辑层和视图层？ 

主要原因是 性能 。web端都运行在webview里，js运算和界面渲染会抢资源导致卡顿，而小程序和app，逻辑层都独立为了单独的 js 引擎，渲染层仍然是webvbiew（app也支持原生渲染）。所以在小程序和app上不支持window，dom等API（app可以在渲染层操作window,dom）

&lt;a name=&quot;heading_436&quot;&gt;  385.  详细描述一下Uniapp的工作原理。 

将Vue.js的 模板语法 转换为各个平台所支持的 原生组件 ，再通过 引擎的渲染器 将其渲染到各个平台上。

同时，Uniapp还提供了平台API以及对各平台的配置文件支持，使得开发者能够方便地在同一份代码下实现对不同平台的适配。

&lt;a name=&quot;heading_437&quot;&gt;  386.  描述一下在Uniapp中如何实现跨平台开发。 

在Uniapp中，使用Vue.js的语法开发，同时通过Uniapp所提供的各平台API和配置文件适配各种平台的差异即可实现跨平台开发。例如，在编写页面的时候，可使用Uniapp提供的原生组件替代HTML标签，然后在编写样式时，可通过编写针对各平台的样式代码，使样式在各平台下呈现一致。

&lt;a name=&quot;heading_438&quot;&gt;  387.  在Uniapp中是否可以使用原生功能？如果可以，如何实现？ 

是的，Uniapp支持使用原生功能。具体实现方式是，可以使用Uniapp提供的API调用各平台的原生组件和接口，然后再将其渲染到对应的平台上。比如，在调用原生摄像头时，可以通过调用Uniapp提供的API获取到原生摄像头组件，并在页面中进行渲染。

&lt;a name=&quot;heading_439&quot;&gt;  388.  在Uniapp中如何处理网络请求？ 

在Uniapp中，可通过Uniapp提供的网络请求方法来处理网络请求。具体实现方式是，在前端代码中编写网络请求代码，使用Uniapp提供的request方法发送请求，并在回调函数中处理响应结果。

&lt;a name=&quot;heading_440&quot;&gt;  389.  描述一下在Uniapp中，组件和页面的区别。 

在Uniapp中，页面和组件的区别在于，页面是一个具体的应用页面，拥有独立的路由地址和生命周期函数，而组件是应用页面中的局部组件，包含在页面中，没有独立的路由地址和生命周期函数。

&lt;a name=&quot;heading_441&quot;&gt;  390.  Uniapp如何实现自定义组件？ 

在Uniapp中，可通过Vue.js的组件机制实现自定义组件。具体实现方式是，编写组件的基本结构和属性方法等，并将组件注册到Vue.js的全局组件或局部组件中，然后在需要使用组件的地方进行调用。

&lt;a name=&quot;heading_442&quot;&gt;  391.  请列出Uniapp工程中有哪些可用的构建模式？ 

Uniapp工程中可用的构建模式有： 开发模式、生产模式、H5模式、跨平台模式 等。

&lt;a name=&quot;heading_443&quot;&gt;  392.  描述一下Uniapp的几种布局方式。 

在Uniapp中，可实现的布局方式有 Flex布局、Grid布局、绝对布局 等。这些布局方式可根据不同的场景来选择使用。

&lt;a name=&quot;heading_444&quot;&gt;  393.  如何在Uniapp中使用vuex来管理全局状态？ 

在Uniapp中，可通过vuex来管理全局状态。具体实现方式是，在应用程序的入口文件中，注入vuex实例，并在其中编写状态管理器，然后在各组件中使用mapState、mapGetters、mapMutations等方法来访问和修改全局状态。

&lt;a name=&quot;heading_445&quot;&gt;  394.  在Uniapp中，如何使用原生SDK以及插件？ 

在Uniapp中，可通过uni-app plus的方式来集成原生SDK和插件。具体实现方式是，在 manifest.json 文件中添加对应的插件设置，并在代码中调用相关API使用内置的SDK和插件。

&lt;a name=&quot;heading_446&quot;&gt;  395.  描述一下在Uniapp中如何实现动态路由。 

在Uniapp中，可通过vue-router实现动态路由。具体实现方式是，在定义路由时，使用动态路由参数设置路由的路径，然后在组件中通过$route.params来获取路由参数，以便进行页面的动态渲染。

&lt;a name=&quot;heading_447&quot;&gt;  396.  一句话总的形容uniapp与vue和微信小程序的区别 

uni-app就是用着vue的指令和小程序的组件和API

&lt;a name=&quot;heading_448&quot;&gt;  397.  uni-app中的生命周期 

&lt;a name=&quot;heading_449&quot;&gt;   1.应用生命周期 

 ```javascript  onLanuch – uni-app 初始化完成时触发（全局只触发一次） onShow – uni-app启动，或从后台进入前台显示 onHide – uni-app从前台进入后台 onError – 当uni-app 报错时触发 onUNiNViewMessage – 对 nvue 页面发送的数据进行监听 onUnhandledRejection – 对未处理的Promise拒绝事件监听函数 onPageNotFound – 页面不存在监听函数 onThemeChange – 监听系统主题变化 |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_450&quot;&gt;   2. 页面生命周期 

 ```javascript onInit – 监听页面初始化，参数同onLoad参数，为上个页面传递的数据，参数类型为Object，触发时机早于onLoad onLoad – 监听页面加载，其参数为上个页面传递的数据，参数类型为Object onShow – 监听页面显示，页面每次出现在屏幕上都触发，包括从下级页面返回露出当前页面 onReady – 监听页面初次渲染 onHide – 监听页面隐藏 onUnload – 监听页面隐藏 onResize – 监听窗口尺寸变化 |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_451&quot;&gt;   3.组件的生命周期 

 ```javascript beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed |
| :----------------------------------------------------------- |

&lt;a name=&quot;heading_452&quot;&gt;  398.  uni-app 中的本地缓存 

同步存储：uni.setStorageSync,获取：uni.getStorageSync

异步存储：uni.setStorage,获取：uni.getStorage

&lt;a name=&quot;heading_453&quot;&gt;  399.  变量 globalData 的理解 

globalDate 和微信小程序中一样，是定义在全局上的对象看，他类似vuex，用来共享全局状态，在组件和页面中可以使用getApp().globalData 来获取和修改全局变量

&lt;a name=&quot;heading_454&quot;&gt;  400.  23.uni-app 跨端原理 

uni-app 分编译器和运行时（runtime），实现一套代码，多端运行主要是这两部分配合完成的 编译器将开发者的代码进行编译，编译的输出物由每个平台各自的runtime进行解析。\

&lt;a name=&quot;heading_455&quot;&gt;  401.  24.不同平台的 runtime 是怎么转义的？ 

小程序端，使用小程序版的vue runtime ，页面路由，组件，api 等方面基本都是转义。 web 端，uni-app的runtime 相比普通的vue项目，多一套ui库，页面路由框架，uni对象。 App 端，uni-app的 runtime 更复杂，DCloud 有一套小程序引擎，打包app时将开发者的代码和DCloud 的小程序打包成apk或ipa

&lt;a name=&quot;heading_456&quot;&gt;  402.  25.uni-app 的编译器是如何特定编译的？ 

在  web、ap p平台，将.vue 文件 编译成  js 代码 ，小程序则拆分shengchengwx,l,wxss ,js等 如果涉及 uts 代码，安卓编译为 kotlin 代码，ios 编译成 swift  代码。 vue2版本的编译器基于\*\* webpack\*\* 实现，vue3通过  vite  实现，性能更快。 同时也支持条件编译，可以指定代码至编译到特定的终端平台。

[ref1]: Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.009.png
[ref2]: Aspose.Words.5e1553c0-9c30-460a-9821-4c542e7e6969.016.png
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fuhaoyu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://chucklery.github.io/2024/09/20/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://chucklery.github.io/2024/09/20/面试题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://chucklery.github.io" target="_blank">Fuhaoyu's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Front-%E9%9D%A2%E8%AF%95%E9%A2%98/">Front 面试题</a></div><div class="post_share"><div class="social-share" data-image="/img/eye.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/20/Tools-Useage/"><img class="prev-cover" src="/img/cry.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Tools_Useage</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/20/React/"><img class="next-cover" src="/img/black.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">网络协议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-number">2.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot"><span class="toc-number">3.</span> <span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">4.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93"><span class="toc-number">5.</span> <span class="toc-text">———————————————–</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/eye.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Fuhaoyu</div><div class="footer_custom_text">原本乌合，清谈值得</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="100,0,0" opacity="1" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>